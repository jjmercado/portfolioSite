import{_ as H}from"./Cg20b7r6.js";import{j as S,e as U,k as j,l as z,m as I,n as W,i as A,p as F,q as G,r as J,s as Q,v as T,x as X,y as Y,z as Z,A as M,B as $,C as K,_ as k,D as aa,c as P,a as C,F as ea,E as ta,o as O,b as na,w as ra,t as x}from"./11c__n-o.js";const sa={trailing:!0};function oa(a,e=25,i={}){if(i={...sa,...i},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let s,n,_=[],r,t;const m=(d,v)=>(r=ia(a,d,v),r.finally(()=>{if(r=null,i.trailing&&t&&!n){const b=m(d,t);return t=null,b}}),r),h=function(...d){return i.trailing&&(t=d),r||new Promise(v=>{const b=!n&&i.leading;clearTimeout(n),n=setTimeout(()=>{n=null;const c=i.leading?s:m(this,d);t=null;for(const f of _)f(c);_=[]},e),b?(s=m(this,d),v(s)):_.push(v)})},o=d=>{d&&(clearTimeout(d),n=null)};return h.isPending=()=>!!n,h.cancel=()=>{o(n),_=[],t=null},h.flush=()=>{if(o(n),!t||r)return;const d=t;return t=null,m(this,d)},h}async function ia(a,e,i){return await a.apply(e,i)}const ca=Symbol.for("nuxt:client-only");function la(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;ua(a[0],a[1])&&a.unshift(e);let[i,s,n={}]=a,_=!1;const r=S(()=>$(i));if(typeof r.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof s!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=U();n.server??=!0,n.default??=fa,n.getCachedData??=V,n.lazy??=!1,n.immediate??=!0,n.deep??=j.deep,n.dedupe??="cancel",n._functionName,t._asyncData[r.value];function m(){const c={cause:"initial",dedupe:n.dedupe};return t._asyncData[r.value]?._init||(c.cachedData=n.getCachedData(r.value,t,{cause:"initial"}),t._asyncData[r.value]=R(t,r.value,s,n,c.cachedData)),()=>t._asyncData[r.value].execute(c)}const h=m(),o=t._asyncData[r.value];o._deps++;const d=n.server!==!1&&t.payload.serverRendered;{let c=function(u){const l=t._asyncData[u];l?._deps&&(l._deps--,l._deps===0&&l?._off())};const f=z();if(f&&d&&n.immediate&&!f.sp&&(f.sp=[]),f&&!f._nuxtOnBeforeMountCbs){f._nuxtOnBeforeMountCbs=[];const u=f._nuxtOnBeforeMountCbs;I(()=>{u.forEach(l=>{l()}),u.splice(0,u.length)}),W(()=>u.splice(0,u.length))}const p=f&&(f._nuxtClientOnly||A(ca,!1));d&&t.isHydrating&&(o.error.value||o.data.value!==void 0)?o.status.value=o.error.value?"error":"success":f&&(!p&&t.payload.serverRendered&&t.isHydrating||n.lazy)&&n.immediate?f._nuxtOnBeforeMountCbs.push(h):n.immediate&&o.status.value!=="success"&&h();const D=J(),y=F(r,(u,l)=>{if((u||l)&&u!==l){_=!0;const B=t._asyncData[l]?.data.value!==void 0,q=t._asyncDataPromises[l]!==void 0,N={cause:"initial",dedupe:n.dedupe};if(!t._asyncData[u]?._init){let E;l&&B?E=t._asyncData[l].data.value:(E=n.getCachedData(u,t,{cause:"initial"}),N.cachedData=E),t._asyncData[u]=R(t,u,s,n,E)}t._asyncData[u]._deps++,l&&c(l),(n.immediate||B||q)&&t._asyncData[u].execute(N),K(()=>{_=!1})}},{flush:"sync"}),g=n.watch?F(n.watch,()=>{_||t._asyncData[r.value]?._execute({cause:"watch",dedupe:n.dedupe})}):()=>{};D&&G(()=>{y(),g(),c(r.value)})}const v={data:w(()=>t._asyncData[r.value]?.data),pending:w(()=>t._asyncData[r.value]?.pending),status:w(()=>t._asyncData[r.value]?.status),error:w(()=>t._asyncData[r.value]?.error),refresh:(...c)=>t._asyncData[r.value]?._init?t._asyncData[r.value].execute(...c):m()(),execute:(...c)=>v.refresh(...c),clear:()=>{const c=t._asyncData[r.value];if(c?._abortController)try{c._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{c._abortController=void 0}L(t,r.value)}},b=Promise.resolve(t._asyncDataPromises[r.value]).then(()=>v);return Object.assign(b,v),b}function w(a){return S({get(){return a()?.value},set(e){const i=a();i&&(i.value=e)}})}function ua(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}function L(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=void 0),a._asyncData[e]&&(a._asyncData[e].data.value=M(a._asyncData[e]._default()),a._asyncData[e].error.value=void 0,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function da(a,e){const i={};for(const s of e)i[s]=a[s];return i}function R(a,e,i,s,n){a.payload._errors[e]??=void 0;const _=s.getCachedData!==V,r=i,t=s.deep?Q:T,m=n!==void 0,h=a.hook("app:data:refresh",async d=>{(!d||d.includes(e))&&await o.execute({cause:"refresh:hook"})}),o={data:t(m?n:s.default()),pending:S(()=>o.status.value==="pending"),error:X(a.payload._errors,e),status:T("idle"),execute:(...d)=>{const[v,b=void 0]=d,c=v&&b===void 0&&typeof v=="object"?v:{};if(a._asyncDataPromises[e]&&(c.dedupe??s.dedupe)==="defer")return a._asyncDataPromises[e];{const D="cachedData"in c?c.cachedData:s.getCachedData(e,a,{cause:c.cause??"refresh:manual"});if(D!==void 0)return a.payload.data[e]=o.data.value=D,o.error.value=void 0,o.status.value="success",Promise.resolve(D)}o._abortController&&o._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),o._abortController=new AbortController,o.status.value="pending";const f=new AbortController,p=new Promise((D,y)=>{try{const g=c.timeout??s.timeout,u=_a([o._abortController?.signal,c?.signal],f.signal,g);if(u.aborted){const l=u.reason;y(l instanceof Error?l:new DOMException(String(l??"Aborted"),"AbortError"));return}return u.addEventListener("abort",()=>{const l=u.reason;y(l instanceof Error?l:new DOMException(String(l??"Aborted"),"AbortError"))},{once:!0,signal:f.signal}),Promise.resolve(r(a,{signal:u})).then(D,y)}catch(g){y(g)}}).then(async D=>{let y=D;s.transform&&(y=await s.transform(D)),s.pick&&(y=da(y,s.pick)),a.payload.data[e]=y,o.data.value=y,o.error.value=void 0,o.status.value="success"}).catch(D=>{if(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==p||o._abortController?.signal.aborted)return a._asyncDataPromises[e];if(typeof DOMException<"u"&&D instanceof DOMException&&D.name==="AbortError")return o.status.value="idle",a._asyncDataPromises[e];o.error.value=Z(D),o.data.value=M(s.default()),o.status.value="error"}).finally(()=>{f.abort(),delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=p,a._asyncDataPromises[e]},_execute:oa((...d)=>o.execute(...d),0,{leading:!0}),_default:s.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{h(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),_||Y(()=>{a._asyncData[e]?._init||(L(a,e),o.execute=()=>Promise.resolve())})}};return o}const fa=()=>{},V=(a,e,i)=>{if(e.isHydrating)return e.payload.data[a];if(i.cause!=="refresh:manual"&&i.cause!=="refresh:hook")return e.static.data[a]};function _a(a,e,i){const s=a.filter(r=>!!r);if(typeof i=="number"&&i>=0){const r=AbortSignal.timeout?.(i);r&&s.push(r)}if(AbortSignal.any)return AbortSignal.any(s);const n=new AbortController;for(const r of s)if(r.aborted){const t=r.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}return n.signal}const _=()=>{const t=s.find(m=>m.aborted)?.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}};for(const r of s)r.addEventListener?.("abort",_,{once:!0,signal:e});return n.signal}const Da={__name:"index",async setup(a){let e,i;const{data:s}=([e,i]=aa(()=>la("devlog-posts",()=>queryContent("/devlog").sort({date:-1}).find())),e=await e,i(),e);return(n,_)=>{const r=H;return O(),P("div",null,[_[0]||(_[0]=C("h1",null,"Devlog",-1)),_[1]||(_[1]=C("p",null,"Hier sind alle meine Entwicklungs-Updates.",-1)),C("ul",null,[(O(!0),P(ea,null,ta(M(s),t=>(O(),P("li",{key:t._path},[na(r,{to:t._path},{default:ra(()=>[C("h2",null,x(t.title),1),C("p",null,x(t.description),1)]),_:2},1032,["to"])]))),128))])])}}},ma=k(Da,[["__scopeId","data-v-6fdc98d5"]]);export{ma as default};
