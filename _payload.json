[{"data":1,"prerenderedAt":660},["ShallowReactive",2],{"games-list":3,"latest-posts-polyslayer":400},[4,130,215,318],{"id":5,"title":6,"body":7,"description":111,"extension":112,"meta":113,"navigation":125,"path":126,"seo":127,"stem":128,"__hash__":129},"games/games/asteroids.md","Asteroids",{"type":8,"value":9,"toc":102},"minimark",[10,15,19,23,26,43,47,50,72,76],[11,12,14],"h3",{"id":13},"projektbeschreibung-asteroids","Projektbeschreibung: Asteroids",[16,17,18],"p",{},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek (Simple and Fast Multimedia Library). Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.",[11,20,22],{"id":21},"das-spielprinzip","Das Spielprinzip",[16,24,25],{},"Der Spieler steuert ein dreieckiges Raumschiff in einem zweidimensionalen Asteroidenfeld. Die Besonderheit liegt in der Steuerung und der Physik:",[27,28,29,37],"ul",{},[30,31,32,36],"li",{},[33,34,35],"strong",{},"Wrapping-World:"," Objekte, die den Bildschirmrand verlassen, erscheinen auf der gegenüberliegenden Seite wieder (Screen Wrapping).",[30,38,39,42],{},[33,40,41],{},"Zerstörung:"," Große Asteroiden zerfallen bei Treffern in kleinere, schnellere Fragmente.",[11,44,46],{"id":45},"steuerung","Steuerung",[16,48,49],{},"Das Spiel ist für zwei Spieler an einer Tastatur konzipiert:",[27,51,52],{},[30,53,54,55,59,60,63,64,67,68,71],{},"Raumschiff: Taste ",[56,57,58],"kbd",{},"W"," (vorwärts), ",[56,61,62],{},"A"," (links Rotieren), ",[56,65,66],{},"D"," (rechts Rotieren) und ",[56,69,70],{},"Leertaste"," (schießen)",[11,73,75],{"id":74},"technische-highlights-features","Technische Highlights & Features",[27,77,78,84,90,96],{},[30,79,80,83],{},[33,81,82],{},"Vektorphysik:"," Berechnung Rotation und Geschwindigkeit basierend auf vektorieller Mathematik.",[30,85,86,89],{},[33,87,88],{},"Kollisionserkennung:"," Implementierung von Hitboxen, um Interaktionen zwischen Geschossen, Asteroiden und dem Schiff zu prüfen.",[30,91,92,95],{},[33,93,94],{},"Game Loop:"," Ein sauberer Game-Loop zur Trennung von Input-Verarbeitung, Logik-Update und Rendering.",[30,97,98,101],{},[33,99,100],{},"Ressourcenmanagement:"," Laden und Verwalten von Texturen über SFML.",{"title":103,"searchDepth":104,"depth":104,"links":105},"",2,[106,108,109,110],{"id":13,"depth":107,"text":14},3,{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.","md",{"image":114,"video":115,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":119,"buildsystem":120,"downloads":121,"tags":124},"/games/asteroids/images/Asteroids.png","/portfolioSite/games/asteroids/videos/Asteroids.mp4","SFML","C++","ca. 1 Monate","https://github.com/jjmercado/Asteroids","CMake",{"windows":122,"linux":123},"/downloads/Asteroids.zip","/downloads/Asteroids.tar.gz",[117,116],true,"/games/asteroids",{"title":6,"description":111},"games/asteroids","coAGsGGZuAGg8ITTcNAFhU_oud1zDT4ZBNkdt1bTp0E",{"id":131,"title":132,"body":133,"description":141,"extension":112,"meta":202,"navigation":125,"path":211,"seo":212,"stem":213,"__hash__":214},"games/games/pac-man.md","Pac-Man",{"type":8,"value":134,"toc":196},[135,139,142,144,147,158,160,162,180,182],[11,136,138],{"id":137},"projektbeschreibung-pac-man","Projektbeschreibung: Pac-Man",[16,140,141],{},"Dieses Projekt ist meine Implementierung des zeitlosen Arcade-Hits Pac-Man, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Der Fokus lag hierbei auf der Umsetzung komplexer Pfadfindungs-Algorithmen und einer kachel-basierten (Tile-based) Weltlogik.",[11,143,22],{"id":21},[16,145,146],{},"Der Spieler steuert Pac-Man durch ein Labyrinth, mit dem Ziel, alle Punkte (Pellets) zu fressen, während er vier Geistern ausweicht. Das Gameplay zeichnet sich durch folgende Mechaniken aus:",[27,148,149,152,155],{},[30,150,151],{},"Tile-Based Navigation: Die gesamte Welt besteht aus einem Raster, das die Bewegung einschränkt und die Kollision mit Wänden definiert.",[30,153,154],{},"Power-Pellets: Das Einsammeln spezieller Items kehrt die Rollen kurzzeitig um, sodass Pac-Man die Geister fressen kann.",[30,156,157],{},"Warp-Tunnel: Seitliche Ausgänge, die den Spieler sofort auf die gegenüberliegende Seite des Spielfelds transportieren.",[11,159,46],{"id":45},[16,161,49],{},[27,163,164],{},[30,165,166,167,169,170,173,174,176,177,179],{},"Pac-Man: Tasten ",[56,168,58],{}," (Hoch), ",[56,171,172],{},"S"," (Runter), ",[56,175,62],{}," (Links), ",[56,178,66],{}," (Rechts)",[11,181,75],{"id":74},[27,183,184,187,190,193],{},[30,185,186],{},"Wegfindungs-KI: Die Wegfindung basiert auf \"Schildern\" die an den Kreuzungen stehen und\neine zufällige Auswahl an Wegen, nach Kreuzung, bietet.",[30,188,189],{},"State-Machine: Steuerung der verschiedenen Zustände von Pac-Man und den Geistern (Chase, Scatter, Frightened).",[30,191,192],{},"Tilemap-System: Effizientes Rendering des Labyrinths durch eine Tilemap, bei der die Map-Daten aus einem Array geladen werden.",[30,194,195],{},"Animations-System: Sprite-Sheet-Animationen für das Öffnen/Schließen des Mundes von Pac-Man.",{"title":103,"searchDepth":104,"depth":104,"links":197},[198,199,200,201],{"id":137,"depth":107,"text":138},{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},{"image":203,"video":204,"gif":103,"engine":103,"framework":116,"language":117,"devtime":205,"githubLink":206,"buildsystem":120,"downloads":207,"tags":210},"/games/pac-man/images/pac-man.png","/portfolioSite/games/pac-man/videos/pac-man.mp4","ca. 3 Monate","https://github.com/jjmercado/Pac-Man",{"windows":208,"linux":209},"/downloads/PacMan.zip","/downloads/PacMan.tar.gz",[117,116],"/games/pac-man",{"title":132,"description":141},"games/pac-man","BEpJYdRm-p7gze6VJMWzsLX-vEs5HYNKNAUJjMisxVc",{"id":216,"title":217,"body":218,"description":305,"extension":112,"meta":306,"navigation":125,"path":314,"seo":315,"stem":316,"__hash__":317},"games/games/pong.md","Pong",{"type":8,"value":219,"toc":299},[220,224,227,229,232,252,254,256,277,279],[11,221,223],{"id":222},"projektbeschreibung-pong","Projektbeschreibung: Pong",[16,225,226],{},"Dieses Projekt ist meine Umsetzung des Arcade-Klassikers Pong, ausgelegt als lokales 2-Spieler-Spiel. Entwickelt in C++ mit der SFML-Bibliothek, bietet es eine solide Basis, die gerne erweitert werden kann.",[11,228,22],{"id":21},[16,230,231],{},"Pong simuliert ein Tischtennis-Duell. Der Ball prallt von Wänden und Paddles ab.",[27,233,234,240,246],{},[30,235,236,239],{},[33,237,238],{},"Reflexions-Gameplay:"," Der Ball prallt von den oberen und unteren Begrenzungen sowie von den Spieler-Paddles ab.",[30,241,242,245],{},[33,243,244],{},"Punktesystem:"," Ein Punkt wird vergeben, wenn der Ball die hintere Spielfeldbegrenzung eines Spielers überschreitet. Das Spiel endet nach Erreichen einer vordefinierten Punktzahl.",[30,247,248,251],{},[33,249,250],{},"Game-Loop:"," Saubere Trennung von Input, Spiellogik und Rendering für flüssiges Gameplay.",[11,253,46],{"id":45},[16,255,49],{},[27,257,258,267],{},[30,259,260,261,263,264,266],{},"Linker Spieler: Tasten ",[56,262,58],{}," (hoch) und ",[56,265,172],{}," (runter)",[30,268,269,270,273,274],{},"Rechter Spieler: Pfeiltasten ",[56,271,272],{},"Oben"," und ",[56,275,276],{},"Unten",[11,278,75],{"id":74},[27,280,281,287,293],{},[30,282,283,286],{},[33,284,285],{},"Vektor-Reflexion:"," Mathematische Berechnung der Abprallwinkel. Die Flugbahn wird manipuliert, je nachdem, an welcher Stelle des Paddles der Ball auftrifft (Steilerer Winkel bei Treffern an den Kanten).",[30,288,289,292],{},[33,290,291],{},"AABB-Kollisionserkennung:"," Implementierung von Axis-Aligned Bounding Boxes zur schnellen und zuverlässigen Erkennung von Kollisionen zwischen Ball, Wänden und Paddles.",[30,294,295,298],{},[33,296,297],{},"UI & Scoring-System:"," Dynamische Anzeige des Spielstands mittels SFML-Text-Komponenten und Echtzeit-Aktualisierung des Spielfelds.",{"title":103,"searchDepth":104,"depth":104,"links":300},[301,302,303,304],{"id":222,"depth":107,"text":223},{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Umsetzung von Pong, dem Pionier der Videospielgeschichte. Entwickelt in C++ mit der SFML-Bibliothek, lag der Schwerpunkt hier auf der präzisen Berechnung von Reflexionsphysik, der Implementierung einer einfachen KI und der Synchronisation von Spielzuständen.",{"image":307,"video":308,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":309,"buildsystem":120,"downloads":310,"tags":313},"/games/pong/images/pong.png","/portfolioSite/games/pong/videos/pong.mp4","https://github.com/jjmercado/Pong",{"windows":311,"linux":312},"/downloads/Pong.zip","/downloads/Pong.tar.gz",[117,116],"/games/pong",{"title":217,"description":305},"games/pong","OvBwtZoRKAJ49iikGYVDPMen8z2gyCnbdklzvZHWEic",{"id":319,"title":320,"body":321,"description":387,"extension":112,"meta":388,"navigation":125,"path":396,"seo":397,"stem":398,"__hash__":399},"games/games/snake-classic.md","Snake Classic",{"type":8,"value":322,"toc":381},[323,327,330,332,335,346,348,365,367],[11,324,326],{"id":325},"projektbeschreibung-snake","Projektbeschreibung: Snake",[16,328,329],{},"Dieses Projekt ist meine Umsetzung des legendären Arcade-Klassikers Snake, entwickelt in C++ mit der SFML-Bibliothek. Das Ziel des Projekts war die Implementierung einer dynamischen Listen-Logik und eines grid-basierten Bewegungssystems, um die klassischen Gameplay-Mechaniken originalgetreu nachzubilden.",[11,331,22],{"id":21},[16,333,334],{},"Der Spieler steuert eine Schlange durch ein zweidimensionales Spielfeld. Mit jedem aufgenommenen Item wächst die Schlange, was die Navigation zunehmend erschwert. Die Kernmechaniken umfassen:",[27,336,337,340,343],{},[30,338,339],{},"Grid-Movement: Die Schlange bewegt sich in festen Schritten auf einem Gitter, wobei die Richtung nur um 90 Grad geändert werden kann.",[30,341,342],{},"Wachstums-Logik: Jedes Mal, wenn der Kopf der Schlange mit einem Futter-Objekt kollidiert, wird ein neues Segment am Ende angehängt.",[30,344,345],{},"Neustart: Das Spiel endet nicht es startet immer wieder neu, sobald der Kopf die Spielfeldbegrenzung berührt oder mit dem eigenen Körper kollidiert (Self-Collision).",[11,347,46],{"id":45},[27,349,350],{},[30,351,352,353,355,356,358,359,361,362,364],{},"Schlange: Taste ",[56,354,58],{}," (hoch), ",[56,357,172],{}," (runter), ",[56,360,62],{}," (links) und ",[56,363,66],{}," (rechts)",[11,366,75],{"id":74},[27,368,369,372,375,378],{},[30,370,371],{},"Datenstrukturen: Effiziente Verwaltung der Schlangensegmente, um das Nachrücken der Glieder performant zu berechnen.",[30,373,374],{},"Grid-basierte Kollisionserkennung: Prüfung der Positionen auf dem Koordinatensystem zur Erkennung von Treffern (Kopf vs. Futter oder Kopf vs. Körper).",[30,376,377],{},"Randomized Spawning: Algorithmus zur Platzierung von Futter auf freien Feldern, die nicht vom Körper der Schlange besetzt sind.",[30,379,380],{},"Frame-Rate Independent Logic: Trennung von Spielgeschwindigkeit (Tick-Rate) und Rendering, um die Schlangengeschwindigkeit unabhängig von der Bildwiederholrate zu steuern.",{"title":103,"searchDepth":104,"depth":104,"links":382},[383,384,385,386],{"id":325,"depth":107,"text":326},{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Snake, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken des Spiels von Grund auf zu programmieren.",{"image":389,"video":390,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":391,"buildsystem":120,"downloads":392,"tags":395},"/games/snake-classic/images/snake-classic.png","/portfolioSite/games/snake-classic/videos/snake-classic.mp4","https://github.com/jjmercado/Snake_classic",{"windows":393,"linux":394},"/downloads/SnakeApp.zip","/downloads/SnakeApp.tar.gz",[117,116],"/games/snake-classic",{"title":320,"description":387},"games/snake-classic","o17kbn-_fcHmRKb5gTC5MCBD7D4t3DxZATqBJqmU76I",[401,495,594],{"id":402,"title":403,"body":404,"date":486,"description":487,"extension":112,"meta":488,"navigation":125,"path":491,"seo":492,"stem":493,"__hash__":494},"polyslayer/devlog/polyslayer/texturing.md","Texturing",{"type":8,"value":405,"toc":482},[406,411,418,421,425,468,472,479],[407,408,410],"h1",{"id":409},"devlog-4-texturierung-der-ausrüstung","Devlog #4: Texturierung der Ausrüstung",[16,412,413,414,417],{},"In diesem Update werfen wir einen Blick auf den Texturierungs-Prozess meiner Assets, am Beispiel des Schwertes. Dies war gleichzeitig ein wichtiger Testlauf für meinen Workflow: Ich experimentiere derzeit noch damit, ob ich die einzelnen Komponenten eines Objekts in einer einzigen ",[33,415,416],{},"Texture-Atlas"," zusammenführe, um die Performance zu optimieren.",[16,419,420],{},"Da ich in diesem Bereich noch viel lerne, wird sich der Prozess in Zukunft sicher noch verfeinern. Aber um das Projekt optisch voranzutreiben und endlich etwas Farbe ins Spiel zu bringen, habe ich nun den ersten kompletten Durchgang gewagt.",[11,422,424],{"id":423},"der-workflow-im-detail","Der Workflow im Detail:",[27,426,427,438,448,458],{},[30,428,429,432,433],{},[33,430,431],{},"UV-Unwrapping:"," Zuerst wurden die UVs erstellt, um die 3D-Oberfläche sauber auf eine 2D-Ebene zu projizieren.\n",[434,435],"nuxt-img",{"src":436,"alt":437},"/games/polyslayer/images/texturing/uv_editing.png","uv unwrapping",[30,439,440,443,444],{},[33,441,442],{},"Normal Map Baking:"," Um feine Details ohne zusätzliche Polygone darzustellen, habe ich eine Normal Map gebacken.\n",[434,445],{"src":446,"alt":447},"/games/polyslayer/images/texturing/sword_normalmap.png","sword normal map",[30,449,450,453,454],{},[33,451,452],{},"Color Texture:"," Hier wurde die Basis-Farbe (Albedo) festgelegt, um dem Schwert seinen Look zu geben.\n",[434,455],{"src":456,"alt":457},"/games/polyslayer/images/texturing/sword_color.png","sword color texture",[30,459,460,463,464],{},[33,461,462],{},"Metallic & Roughness:"," Zum Abschluss wurden die Materialeigenschaften definiert, damit Metall auch wirklich wie Metall glänzt.\n",[434,465],{"src":466,"alt":467},"/games/polyslayer/images/texturing/sword_metal.png","sword metal texture",[11,469,471],{"id":470},"das-ergebnis","Das Ergebnis",[16,473,474,475],{},"Nachdem alle Maps kombiniert wurden, ist hier das fertige Schwert in Blender:\n",[434,476],{"src":477,"alt":478},"/games/polyslayer/images/texturing/sword_texturing_result.png","sword result",[480,481],"hr",{},{"title":103,"searchDepth":104,"depth":104,"links":483},[484,485],{"id":423,"depth":107,"text":424},{"id":470,"depth":107,"text":471},"2025-02-05T00:00:00.000Z","Texturing der Ausrüstung",{"project":489,"project_image":490},"PolySlayer","/games/polyslayer/images/thirdCharacter.png","/devlog/polyslayer/texturing",{"title":403,"description":487},"devlog/polyslayer/texturing","Ix3oR2pI1E0vOFYmQF_mklVq1C0n-veK3Jm3gyztZRo",{"id":496,"title":497,"body":498,"date":587,"description":588,"extension":112,"meta":589,"navigation":125,"path":590,"seo":591,"stem":592,"__hash__":593},"polyslayer/devlog/polyslayer/retopoWarrior.md","Warrior Retopo",{"type":8,"value":499,"toc":580},[500,504,511,515,526,528,532,543,545,549,556,558,560,567,569,573],[407,501,503],{"id":502},"devlog-4-das-retopology-des-hauptcharakters","Devlog #4: Das Retopology des Hauptcharakters",[16,505,506,507,510],{},"Nachdem das High-Poly-Sculpting abgeschlossen ist, stand in den letzten Tagen ein entscheidender Schritt an: das ",[33,508,509],{},"Retopology",". Ziel war es, die Millionen von Polygonen in ein sauberes, performantes Mesh zu verwandeln, das bereit für Rigging und Animationen in Blender ist.",[11,512,514],{"id":513},"der-fokus-auf-die-details","Der Fokus auf die Details",[16,516,517,518,521,522],{},"Begonnen habe ich mit den komplexesten Bereichen. Da ich den Prozess von vielen Vertices zu weniger einfacher finde, habe ich mit den ",[33,519,520],{},"Ohren, der Nase und dem restlichen Kopf"," gestartet, um einen sauberen Edge-Flow zu garantieren.\n",[434,523],{"src":524,"alt":525},"/games/polyslayer/images/retopo/char/mainChar_retopo_1.png","Retopo Char Ears",[480,527],{},[11,529,531],{"id":530},"von-den-extremitäten-zum-core","Von den Extremitäten zum Core",[16,533,534,535,538,539],{},"Nach dem Kopf folgte der Hals als Übergang zum Torso. Ein weiterer kritischer Punkt waren die ",[33,536,537],{},"Hände",". Da der Warrior später sein Schwert fest im Griff haben muss, ist hier eine präzise Topologie wichtig, um unschöne Verformungen beim Greifen zu vermeiden.\n",[434,540],{"src":541,"alt":542},"/games/polyslayer/images/retopo/char/mainChar_retopo_2.png","Retopo Char Hands",[480,544],{},[11,546,548],{"id":547},"den-körper-schließen","Den Körper schließen",[16,550,551,552],{},"Vom Oberkörper aus habe ich das Mesh nach unten hin vervollständigt und schließlich auf die Beine aufgesplittet. Hier lag der Fokus besonders auf den Gelenken (Knie und Hüfte), um genügend \"Loops\" für saubere Deformationen beim Laufen und Kämpfen zu haben.\n",[434,553],{"src":554,"alt":555},"/games/polyslayer/images/retopo/char/mainChar_retopo_3.png","Retopo Char Body",[480,557],{},[11,559,471],{"id":470},[16,561,562,563],{},"Das fertige Modell ist nun bereit für den nächsten Schritt. Im Vergleich zum massiven Sculpting-Modell ist es jetzt leichtgewichtig und perfekt für die Echtzeit-Berechnung optimiert.\n",[564,565],"video",{"loop":125,"autoPlay":125,"src":566},"/portfolioSite/games/polyslayer/videos/finishedRetopoMainChar.mp4",[480,568],{},[11,570,572],{"id":571},"die-rüstung","Die Rüstung",[16,574,575,576],{},"Die Rüstung wurde ebenfalls optimiert.\n",[434,577],{"src":578,"alt":579},"/games/polyslayer/images/retopo/armor/retopo_armor.png","Retopo Armor",{"title":103,"searchDepth":104,"depth":104,"links":581},[582,583,584,585,586],{"id":513,"depth":107,"text":514},{"id":530,"depth":107,"text":531},{"id":547,"depth":107,"text":548},{"id":470,"depth":107,"text":471},{"id":571,"depth":107,"text":572},"2025-02-04T00:00:00.000Z","Der Prozess der Retopology: Optimierung des Hauptcharakters für maximale Performance.",{"project":489,"project_image":490},"/devlog/polyslayer/retopowarrior",{"title":497,"description":588},"devlog/polyslayer/retopoWarrior","jUry_1fUEg9xH1lVQeYfiQrNS6BnRcbueIhizk4lD1A",{"id":595,"title":596,"body":597,"date":652,"description":653,"extension":112,"meta":654,"navigation":125,"path":656,"seo":657,"stem":658,"__hash__":659},"polyslayer/devlog/polyslayer/erläuterung.md","Erläuterung",{"type":8,"value":598,"toc":649},[599,603,605,609,614,617,620,623,644,647],[407,600,602],{"id":601},"devlog-3-was-ist-alles-passiert","Devlog #3: Was ist alles passiert",[480,604],{},[11,606,608],{"id":607},"die-letzten-6-monate","Die letzten 6 Monate",[16,610,611],{},[33,612,613],{},"Vom Code-Enthusiasten zum Godot-User: Mein 2025 in der Spieleentwicklung",[16,615,616],{},"Eigentlich wollte ich Ende 2025 schon eine fertige Kampf-Demo präsentieren. Spoiler: Hat nicht ganz geklappt – aber aus den besten Gründen!",[16,618,619],{},"Nachdem mir Unity mit ihrem \"Cloud-Zwang\" und der unsicheren Preispolitik den letzten Nerv geraubt hat, bin ich komplett auf Godot umgestiegen. Ja, ich liebe C++ und hätte fast alles selbst programmiert, aber ich will ein Spiel fertigstellen und keine Engine-Entwicklungs-Odyssee starten.",[16,621,622],{},"Die letzten Monate waren ein riesiges Experimentierfeld:",[624,625,626,632,638],"ol",{},[30,627,628,631],{},[33,629,630],{},"Blender-Pipeline:"," Modelle, Häuser und Waffen exportieren, bis der Workflow sitzt.",[30,633,634,637],{},[33,635,636],{},"Leben in der Bude:"," Pathfinding für Wölfe und Hasen implementiert.",[30,639,640,643],{},[33,641,642],{},"Visuals:"," Shader-Spielereien und Partikeleffekte für leuchtende Schwerter.",[16,645,646],{},"Es hat länger gedauert als geplant, aber das Gelernte ist Gold wert. Sobald die überarbeitenden Modelle fertig sind, in diesem Fall der Warrior und als Gegner entweder ein Wolf oder einen Drachen, sowie die Texturen und Animationen, bin ich bereit für das Kampfsystem!",[480,648],{},{"title":103,"searchDepth":104,"depth":104,"links":650},[651],{"id":607,"depth":107,"text":608},"2025-01-31T00:00:00.000Z","Was ist in den letzten 6 Monaten passiert",{"project":489,"project_image":655},"/games/polyslayer/images/placeholder.png","/devlog/polyslayer/erlauterung",{"title":596,"description":653},"devlog/polyslayer/erläuterung","MqGnMnzHLdFugqAQRjvF9VlFLiAtuadOXHbGgj0Xxwg",1770375904240]