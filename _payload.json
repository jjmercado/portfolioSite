[{"data":1,"prerenderedAt":396},["ShallowReactive",2],{"games-list":3,"latest-posts-polyslayer":311},[4,87,154,246],{"id":5,"title":6,"body":7,"description":68,"extension":69,"meta":70,"navigation":82,"path":83,"seo":84,"stem":85,"__hash__":86},"games/games/asteroids.md","Asteroids",{"type":8,"value":9,"toc":60},"minimark",[10,15,19,23,26,39,43],[11,12,14],"h3",{"id":13},"projektbeschreibung-asteroids","Projektbeschreibung: Asteroids",[16,17,18],"p",{},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek (Simple and Fast Multimedia Library). Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.",[11,20,22],{"id":21},"das-spielprinzip","Das Spielprinzip",[16,24,25],{},"Der Spieler steuert ein dreieckiges Raumschiff in einem zweidimensionalen Asteroidenfeld. Die Besonderheit liegt in der Steuerung und der Physik:",[27,28,29,33,36],"ul",{},[30,31,32],"li",{},"Trägheit: Das Schiff bewegt sich nach dem Beschleunigen physikalisch korrekt weiter, was     präzises Manövrieren erfordert.",[30,34,35],{},"Wrapping-World: Objekte, die den Bildschirmrand verlassen, erscheinen auf der gegenüberliegenden Seite wieder (Screen Wrapping).",[30,37,38],{},"Zerstörung: Große Asteroiden zerfallen bei Treffern in kleinere, schnellere Fragmente.",[11,40,42],{"id":41},"technische-highlights-features","Technische Highlights & Features",[27,44,45,48,51,54,57],{},[30,46,47],{},"Objektorientierte Programmierung: Umsetzung von Klassen für Ship, Bullet, Asteroid mit Vererbung und Polymorphie.",[30,49,50],{},"Vektorphysik: Berechnung Rotation und Geschwindigkeit basierend auf vektorieller Mathematik.",[30,52,53],{},"Kollisionserkennung: Implementierung von Hitboxen, um Interaktionen zwischen Geschossen, Asteroiden und dem Schiff zu prüfen.",[30,55,56],{},"Game Loop: Ein sauberer Game-Loop zur Trennung von Input-Verarbeitung, Logik-Update und Rendering.",[30,58,59],{},"Ressourcenmanagement: Laden und Verwalten von Texturen über SFML.",{"title":61,"searchDepth":62,"depth":62,"links":63},"",2,[64,66,67],{"id":13,"depth":65,"text":14},3,{"id":21,"depth":65,"text":22},{"id":41,"depth":65,"text":42},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.","md",{"image":71,"video":72,"gif":61,"engine":61,"framework":73,"language":74,"devtime":75,"githubLink":76,"buildsystem":77,"downloads":78,"tags":81},"/games/asteroids/images/Asteroids.png","/portfolioSite/games/asteroids/videos/Asteroids.mp4","SFML","C++","ca. 2 Monate","https://github.com/jjmercado/Asteroids","CMake",{"windows":79,"linux":80},"/downloads/crawler_win.zip","/downloads/Asteroids.tar.gz",[74,73],true,"/games/asteroids",{"title":6,"description":68},"games/asteroids","vsbGkvA41BM3S-ofN8gNzB3uY63LgEGQjtwh_Y_ungU",{"id":88,"title":89,"body":90,"description":98,"extension":69,"meta":142,"navigation":82,"path":150,"seo":151,"stem":152,"__hash__":153},"games/games/pac-man.md","Pac-Man",{"type":8,"value":91,"toc":137},[92,96,99,101,104,118,120],[11,93,95],{"id":94},"projektbeschreibung-pac-man","Projektbeschreibung: Pac-Man",[16,97,98],{},"Dieses Projekt ist meine Implementierung des zeitlosen Arcade-Hits Pac-Man, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Der Fokus lag hierbei auf der Umsetzung komplexer Pfadfindungs-Algorithmen und einer kachel-basierten (Tile-based) Weltlogik.",[11,100,22],{"id":21},[16,102,103],{},"Der Spieler steuert Pac-Man durch ein Labyrinth, mit dem Ziel, alle Punkte (Pellets) zu fressen, während er vier Geistern ausweicht. Das Gameplay zeichnet sich durch folgende Mechaniken aus:",[27,105,106,109,112,115],{},[30,107,108],{},"Tile-Based Navigation: Die gesamte Welt besteht aus einem Raster, das die Bewegung einschränkt und die Kollision mit Wänden definiert.",[30,110,111],{},"Geister-KI: Jedes der vier Geister-Objekte verfolgt eine eigene Strategie (z. B. direktes Verfolgen, Abfangen oder zufälliges Umherschweifen).",[30,113,114],{},"Power-Pellets: Das Einsammeln spezieller Items kehrt die Rollen kurzzeitig um, sodass Pac-Man die Geister fressen kann.",[30,116,117],{},"Warp-Tunnel: Seitliche Ausgänge, die den Spieler sofort auf die gegenüberliegende Seite des Spielfelds transportieren.",[11,119,42],{"id":41},[27,121,122,125,128,131,134],{},[30,123,124],{},"Wegfindungs-KI: Implementierung von Algorithmen zur Richtungsentscheidung der Geister (z. B. Ziel-Kachel-Berechnung basierend auf Distanzmetriken wie der Manhattan-Distanz).",[30,126,127],{},"State-Machine: Steuerung der verschiedenen Zustände von Pac-Man und den Geistern (Chase, Scatter, Frightened) mittels einer robusten State-Machine.",[30,129,130],{},"Tilemap-System: Effizientes Rendering des Labyrinths durch eine Tilemap, bei der die Map-Daten aus einer Textdatei oder einem Array geladen werden.",[30,132,133],{},"Präzise Kollisionslogik: Prüfung von Kollisionen auf Sub-Pixel-Ebene innerhalb des Rasters, um ein flüssiges „Abbiegen“ an Ecken zu ermöglichen (Pre-turn Logic).",[30,135,136],{},"Animations-System: Sprite-Sheet-Animationen für das Öffnen/Schließen des Mundes von Pac-Man sowie die Blickrichtung der Geister.",{"title":61,"searchDepth":62,"depth":62,"links":138},[139,140,141],{"id":94,"depth":65,"text":95},{"id":21,"depth":65,"text":22},{"id":41,"depth":65,"text":42},{"image":143,"video":144,"gif":61,"engine":61,"framework":73,"language":74,"devtime":145,"githubLink":146,"buildsystem":77,"downloads":147,"tags":149},"/games/pac-man/images/pac-man.png","/portfolioSite/games/pac-man/videos/pac-man.mp4","ca. 3 Monate","https://github.com/jjmercado/Pac-Man",{"windows":79,"linux":148},"/downloads/PacMan.tar.gz",[74,73],"/games/pac-man",{"title":89,"description":98},"games/pac-man","Py1UJvRlklXKx42VTMOEP2TF3Fsg_NwKozPmG84-bW4",{"id":155,"title":156,"body":157,"description":233,"extension":69,"meta":234,"navigation":82,"path":242,"seo":243,"stem":244,"__hash__":245},"games/games/pong.md","Pong",{"type":8,"value":158,"toc":228},[159,163,166,168,171,176,181,185,190,194,199,201,205,210,214,219,223],[11,160,162],{"id":161},"projektbeschreibung-pong","Projektbeschreibung: Pong",[16,164,165],{},"Dieses Projekt ist meine Umsetzung des Arcade-Klassikers Pong, ausgelegt als lokales 2-Spieler-Spiel. Entwickelt in C++ mit der SFML-Bibliothek, bietet es eine solide Basis, die gerne erweitert werden kann.",[11,167,22],{"id":21},[16,169,170],{},"Pong simuliert ein Tischtennis-Duell. Der Ball prallt von Wänden und Paddles ab.",[172,173,175],"h4",{"id":174},"reflexions-gameplay","Reflexions-Gameplay:",[27,177,178],{},[30,179,180],{},"Der Ball prallt von den oberen und unteren Begrenzungen sowie von den Spieler-Paddles ab.",[172,182,184],{"id":183},"punktesystem","Punktesystem:",[27,186,187],{},[30,188,189],{},"Ein Punkt wird vergeben, wenn der Ball die hintere Spielfeldbegrenzung eines Spielers überschreitet. Das Spiel endet nach Erreichen einer vordefinierten Punktzahl.",[172,191,193],{"id":192},"game-loop","Game-Loop:",[27,195,196],{},[30,197,198],{},"Saubere Trennung von Input, Spiellogik und Rendering für flüssiges Gameplay.",[11,200,42],{"id":41},[172,202,204],{"id":203},"vektor-reflexion","Vektor-Reflexion:",[27,206,207],{},[30,208,209],{},"Mathematische Berechnung der Abprallwinkel. Die Flugbahn wird manipuliert, je nachdem, an welcher Stelle des Paddles der Ball auftrifft (Steilerer Winkel bei Treffern an den Kanten).",[172,211,213],{"id":212},"aabb-kollisionserkennung","AABB-Kollisionserkennung:",[27,215,216],{},[30,217,218],{},"Implementierung von Axis-Aligned Bounding Boxes zur schnellen und zuverlässigen Erkennung von Kollisionen zwischen Ball, Wänden und Paddles.",[172,220,222],{"id":221},"ui-scoring-system","UI & Scoring-System:",[27,224,225],{},[30,226,227],{},"Dynamische Anzeige des Spielstands mittels SFML-Text-Komponenten und Echtzeit-Aktualisierung des Spielfelds.",{"title":61,"searchDepth":62,"depth":62,"links":229},[230,231,232],{"id":161,"depth":65,"text":162},{"id":21,"depth":65,"text":22},{"id":41,"depth":65,"text":42},"Dieses Projekt ist meine Umsetzung von Pong, dem Pionier der Videospielgeschichte. Entwickelt in C++ mit der SFML-Bibliothek, lag der Schwerpunkt hier auf der präzisen Berechnung von Reflexionsphysik, der Implementierung einer einfachen KI und der Synchronisation von Spielzuständen.",{"image":235,"video":236,"gif":61,"engine":61,"framework":73,"language":74,"devtime":237,"githubLink":238,"buildsystem":77,"downloads":239,"tags":241},"/games/pong/images/pong.png","/portfolioSite/games/pong/videos/pong.mp4","ca. 1 Monate","https://github.com/jjmercado/Pong",{"windows":79,"linux":240},"/downloads/Pong.tar.gz",[74,73],"/games/pong",{"title":156,"description":233},"games/pong","7H5f0xFAWEem_1ZnHLEKetgjS1VqWr8sL-ACzW0dkPU",{"id":247,"title":248,"body":249,"description":298,"extension":69,"meta":299,"navigation":82,"path":307,"seo":308,"stem":309,"__hash__":310},"games/games/snake-classic.md","Snake Classic",{"type":8,"value":250,"toc":293},[251,255,258,260,263,274,276],[11,252,254],{"id":253},"projektbeschreibung-snake","Projektbeschreibung: Snake",[16,256,257],{},"Dieses Projekt ist meine Umsetzung des legendären Arcade-Klassikers Snake, entwickelt in C++ mit der SFML-Bibliothek. Das Ziel des Projekts war die Implementierung einer dynamischen Listen-Logik und eines grid-basierten Bewegungssystems, um die klassischen Gameplay-Mechaniken originalgetreu nachzubilden.",[11,259,22],{"id":21},[16,261,262],{},"Der Spieler steuert eine Schlange durch ein zweidimensionales Spielfeld. Mit jedem aufgenommenen Item wächst die Schlange, was die Navigation zunehmend erschwert. Die Kernmechaniken umfassen:",[27,264,265,268,271],{},[30,266,267],{},"Grid-Movement: Die Schlange bewegt sich in festen Schritten auf einem unsichtbaren Gitter, wobei die Richtung nur um 90 Grad geändert werden kann.",[30,269,270],{},"Wachstums-Logik: Jedes Mal, wenn der Kopf der Schlange mit einem Futter-Objekt kollidiert, wird ein neues Segment am Ende angehängt.",[30,272,273],{},"Game-Over-Conditions: Das Spiel endet, sobald der Kopf die Spielfeldbegrenzung berührt oder mit dem eigenen Körper kollidiert (Self-Collision).",[11,275,42],{"id":41},[27,277,278,281,284,287,290],{},[30,279,280],{},"Datenstrukturen: Effiziente Verwaltung der Schlangensegmente (z. B. mittels std::vector oder std::deque), um das Nachrücken der Glieder performant zu berechnen.",[30,282,283],{},"Input-Buffering: Implementierung eines Buffers für Tastatureingaben, um zu verhindern, dass die Schlange durch zu schnelle Richtungswechsel eine unmögliche 180-Grad-Wende in sich selbst vollführt.",[30,285,286],{},"Grid-basierte Kollisionserkennung: Mathematische Prüfung der Positionen auf dem Koordinatensystem zur Erkennung von Treffern (Kopf vs. Futter oder Kopf vs. Körper).",[30,288,289],{},"Randomized Spawning: Algorithmus zur Platzierung von Futter auf freien Feldern, die nicht vom Körper der Schlange besetzt sind.",[30,291,292],{},"Frame-Rate Independent Logic: Trennung von Spielgeschwindigkeit (Tick-Rate) und Rendering, um die Schlangengeschwindigkeit unabhängig von der Bildwiederholrate zu steuern.",{"title":61,"searchDepth":62,"depth":62,"links":294},[295,296,297],{"id":253,"depth":65,"text":254},{"id":21,"depth":65,"text":22},{"id":41,"depth":65,"text":42},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Snake, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken des Spiels von Grund auf zu programmieren.",{"image":300,"video":301,"gif":61,"engine":61,"framework":73,"language":74,"devtime":237,"githubLink":302,"buildsystem":77,"downloads":303,"tags":306},"/games/snake-classic/images/snake-classic.png","/portfolioSite/games/snake-classic/videos/snake-classic.mp4","https://github.com/jjmercado/Snake_classic",{"windows":304,"linux":305},"/downloads/SnakeApp.zip","/downloads/SnakeApp.tar.gz",[74,73],"/games/snake-classic",{"title":248,"description":298},"games/snake-classic","VnGykXsS-x_QLiwiybE1h7iqGoH-r2mY7PC-Sbo9Bk4",[312,358],{"id":313,"title":314,"body":315,"date":350,"description":351,"extension":69,"meta":352,"navigation":82,"path":354,"seo":355,"stem":356,"__hash__":357},"polyslayer/devlog/polyslayer/zweiter-eintrag.md","Mein zweiter",{"type":8,"value":316,"toc":348},[317,322,325,328,344],[318,319,321],"h1",{"id":320},"willkommen-zu-meinem-devlog","Willkommen zu meinem Devlog",[16,323,324],{},"dungeon-crawler",[16,326,327],{},"anderer text",[329,330,334],"pre",{"className":331,"code":332,"language":333,"meta":61,"style":61},"language-javascript shiki shiki-themes github-light github-dark","console.log('Hello, Nuxt Content!');\n","javascript",[335,336,337],"code",{"__ignoreMap":61},[338,339,342],"span",{"class":340,"line":341},"line",1,[338,343,332],{},[345,346,347],"style",{},"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}",{"title":61,"searchDepth":62,"depth":62,"links":349},[],"2025-12-19T00:00:00.000Z","Eine kurze Zusammenfassung, worum es in diesem Eintrag geht.",{"project":324,"project_image":353},"/games/polyslayer/images/placeholder.png","/devlog/polyslayer/zweiter-eintrag",{"title":314,"description":351},"devlog/polyslayer/zweiter-eintrag","W38GfhBG0a5jUDuOP-QzSRg9Jafk5QBzL1pT9NpwRo8",{"id":359,"title":360,"body":361,"date":390,"description":351,"extension":69,"meta":391,"navigation":82,"path":392,"seo":393,"stem":394,"__hash__":395},"polyslayer/devlog/polyslayer/erster-eintrag.md","Mein erster Devlog-Eintrag! dung",{"type":8,"value":362,"toc":388},[363,365,367,370,378,386],[318,364,321],{"id":320},[16,366,324],{},[16,368,369],{},"Das ist der erste Eintrag, der mit Nuxt Content erstellt wurde. Es ist wirklich einfach!",[16,371,372,373,377],{},"Du kannst hier ganz normal ",[374,375,376],"strong",{},"Markdown"," verwenden.",[329,379,380],{"className":331,"code":332,"language":333,"meta":61,"style":61},[335,381,382],{"__ignoreMap":61},[338,383,384],{"class":340,"line":341},[338,385,332],{},[345,387,347],{},{"title":61,"searchDepth":62,"depth":62,"links":389},[],"2025-12-18T00:00:00.000Z",{"project":324,"project_image":353},"/devlog/polyslayer/erster-eintrag",{"title":360,"description":351},"devlog/polyslayer/erster-eintrag","tk8zsJ35nFIqd-uUVSoYHX1d2zEg0owwU278dE_V3-A",1768571037003]