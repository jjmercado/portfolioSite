[{"data":1,"prerenderedAt":704},["ShallowReactive",2],{"games-list":3,"latest-posts-polyslayer":400},[4,130,215,318],{"id":5,"title":6,"body":7,"description":111,"extension":112,"meta":113,"navigation":125,"path":126,"seo":127,"stem":128,"__hash__":129},"games/games/asteroids.md","Asteroids",{"type":8,"value":9,"toc":102},"minimark",[10,15,19,23,26,43,47,50,72,76],[11,12,14],"h3",{"id":13},"projektbeschreibung-asteroids","Projektbeschreibung: Asteroids",[16,17,18],"p",{},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek (Simple and Fast Multimedia Library). Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.",[11,20,22],{"id":21},"das-spielprinzip","Das Spielprinzip",[16,24,25],{},"Der Spieler steuert ein dreieckiges Raumschiff in einem zweidimensionalen Asteroidenfeld. Die Besonderheit liegt in der Steuerung und der Physik:",[27,28,29,37],"ul",{},[30,31,32,36],"li",{},[33,34,35],"strong",{},"Wrapping-World:"," Objekte, die den Bildschirmrand verlassen, erscheinen auf der gegenüberliegenden Seite wieder (Screen Wrapping).",[30,38,39,42],{},[33,40,41],{},"Zerstörung:"," Große Asteroiden zerfallen bei Treffern in kleinere, schnellere Fragmente.",[11,44,46],{"id":45},"steuerung","Steuerung",[16,48,49],{},"Das Spiel ist für zwei Spieler an einer Tastatur konzipiert:",[27,51,52],{},[30,53,54,55,59,60,63,64,67,68,71],{},"Raumschiff: Taste ",[56,57,58],"kbd",{},"W"," (vorwärts), ",[56,61,62],{},"A"," (links Rotieren), ",[56,65,66],{},"D"," (rechts Rotieren) und ",[56,69,70],{},"Leertaste"," (schießen)",[11,73,75],{"id":74},"technische-highlights-features","Technische Highlights & Features",[27,77,78,84,90,96],{},[30,79,80,83],{},[33,81,82],{},"Vektorphysik:"," Berechnung Rotation und Geschwindigkeit basierend auf vektorieller Mathematik.",[30,85,86,89],{},[33,87,88],{},"Kollisionserkennung:"," Implementierung von Hitboxen, um Interaktionen zwischen Geschossen, Asteroiden und dem Schiff zu prüfen.",[30,91,92,95],{},[33,93,94],{},"Game Loop:"," Ein sauberer Game-Loop zur Trennung von Input-Verarbeitung, Logik-Update und Rendering.",[30,97,98,101],{},[33,99,100],{},"Ressourcenmanagement:"," Laden und Verwalten von Texturen über SFML.",{"title":103,"searchDepth":104,"depth":104,"links":105},"",2,[106,108,109,110],{"id":13,"depth":107,"text":14},3,{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.","md",{"image":114,"video":115,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":119,"buildsystem":120,"downloads":121,"tags":124},"/games/asteroids/images/Asteroids.png","/portfolioSite/games/asteroids/videos/Asteroids.mp4","SFML","C++","ca. 1 Monate","https://github.com/jjmercado/Asteroids","CMake",{"windows":122,"linux":123},"/downloads/Asteroids.zip","/downloads/Asteroids.tar.gz",[117,116],true,"/games/asteroids",{"title":6,"description":111},"games/asteroids","coAGsGGZuAGg8ITTcNAFhU_oud1zDT4ZBNkdt1bTp0E",{"id":131,"title":132,"body":133,"description":141,"extension":112,"meta":202,"navigation":125,"path":211,"seo":212,"stem":213,"__hash__":214},"games/games/pac-man.md","Pac-Man",{"type":8,"value":134,"toc":196},[135,139,142,144,147,158,160,162,180,182],[11,136,138],{"id":137},"projektbeschreibung-pac-man","Projektbeschreibung: Pac-Man",[16,140,141],{},"Dieses Projekt ist meine Implementierung des zeitlosen Arcade-Hits Pac-Man, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Der Fokus lag hierbei auf der Umsetzung komplexer Pfadfindungs-Algorithmen und einer kachel-basierten (Tile-based) Weltlogik.",[11,143,22],{"id":21},[16,145,146],{},"Der Spieler steuert Pac-Man durch ein Labyrinth, mit dem Ziel, alle Punkte (Pellets) zu fressen, während er vier Geistern ausweicht. Das Gameplay zeichnet sich durch folgende Mechaniken aus:",[27,148,149,152,155],{},[30,150,151],{},"Tile-Based Navigation: Die gesamte Welt besteht aus einem Raster, das die Bewegung einschränkt und die Kollision mit Wänden definiert.",[30,153,154],{},"Power-Pellets: Das Einsammeln spezieller Items kehrt die Rollen kurzzeitig um, sodass Pac-Man die Geister fressen kann.",[30,156,157],{},"Warp-Tunnel: Seitliche Ausgänge, die den Spieler sofort auf die gegenüberliegende Seite des Spielfelds transportieren.",[11,159,46],{"id":45},[16,161,49],{},[27,163,164],{},[30,165,166,167,169,170,173,174,176,177,179],{},"Pac-Man: Tasten ",[56,168,58],{}," (Hoch), ",[56,171,172],{},"S"," (Runter), ",[56,175,62],{}," (Links), ",[56,178,66],{}," (Rechts)",[11,181,75],{"id":74},[27,183,184,187,190,193],{},[30,185,186],{},"Wegfindungs-KI: Die Wegfindung basiert auf \"Schildern\" die an den Kreuzungen stehen und\neine zufällige Auswahl an Wegen, nach Kreuzung, bietet.",[30,188,189],{},"State-Machine: Steuerung der verschiedenen Zustände von Pac-Man und den Geistern (Chase, Scatter, Frightened).",[30,191,192],{},"Tilemap-System: Effizientes Rendering des Labyrinths durch eine Tilemap, bei der die Map-Daten aus einem Array geladen werden.",[30,194,195],{},"Animations-System: Sprite-Sheet-Animationen für das Öffnen/Schließen des Mundes von Pac-Man.",{"title":103,"searchDepth":104,"depth":104,"links":197},[198,199,200,201],{"id":137,"depth":107,"text":138},{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},{"image":203,"video":204,"gif":103,"engine":103,"framework":116,"language":117,"devtime":205,"githubLink":206,"buildsystem":120,"downloads":207,"tags":210},"/games/pac-man/images/pac-man.png","/portfolioSite/games/pac-man/videos/pac-man.mp4","ca. 3 Monate","https://github.com/jjmercado/Pac-Man",{"windows":208,"linux":209},"/downloads/PacMan.zip","/downloads/PacMan.tar.gz",[117,116],"/games/pac-man",{"title":132,"description":141},"games/pac-man","BEpJYdRm-p7gze6VJMWzsLX-vEs5HYNKNAUJjMisxVc",{"id":216,"title":217,"body":218,"description":305,"extension":112,"meta":306,"navigation":125,"path":314,"seo":315,"stem":316,"__hash__":317},"games/games/pong.md","Pong",{"type":8,"value":219,"toc":299},[220,224,227,229,232,252,254,256,277,279],[11,221,223],{"id":222},"projektbeschreibung-pong","Projektbeschreibung: Pong",[16,225,226],{},"Dieses Projekt ist meine Umsetzung des Arcade-Klassikers Pong, ausgelegt als lokales 2-Spieler-Spiel. Entwickelt in C++ mit der SFML-Bibliothek, bietet es eine solide Basis, die gerne erweitert werden kann.",[11,228,22],{"id":21},[16,230,231],{},"Pong simuliert ein Tischtennis-Duell. Der Ball prallt von Wänden und Paddles ab.",[27,233,234,240,246],{},[30,235,236,239],{},[33,237,238],{},"Reflexions-Gameplay:"," Der Ball prallt von den oberen und unteren Begrenzungen sowie von den Spieler-Paddles ab.",[30,241,242,245],{},[33,243,244],{},"Punktesystem:"," Ein Punkt wird vergeben, wenn der Ball die hintere Spielfeldbegrenzung eines Spielers überschreitet. Das Spiel endet nach Erreichen einer vordefinierten Punktzahl.",[30,247,248,251],{},[33,249,250],{},"Game-Loop:"," Saubere Trennung von Input, Spiellogik und Rendering für flüssiges Gameplay.",[11,253,46],{"id":45},[16,255,49],{},[27,257,258,267],{},[30,259,260,261,263,264,266],{},"Linker Spieler: Tasten ",[56,262,58],{}," (hoch) und ",[56,265,172],{}," (runter)",[30,268,269,270,273,274],{},"Rechter Spieler: Pfeiltasten ",[56,271,272],{},"Oben"," und ",[56,275,276],{},"Unten",[11,278,75],{"id":74},[27,280,281,287,293],{},[30,282,283,286],{},[33,284,285],{},"Vektor-Reflexion:"," Mathematische Berechnung der Abprallwinkel. Die Flugbahn wird manipuliert, je nachdem, an welcher Stelle des Paddles der Ball auftrifft (Steilerer Winkel bei Treffern an den Kanten).",[30,288,289,292],{},[33,290,291],{},"AABB-Kollisionserkennung:"," Implementierung von Axis-Aligned Bounding Boxes zur schnellen und zuverlässigen Erkennung von Kollisionen zwischen Ball, Wänden und Paddles.",[30,294,295,298],{},[33,296,297],{},"UI & Scoring-System:"," Dynamische Anzeige des Spielstands mittels SFML-Text-Komponenten und Echtzeit-Aktualisierung des Spielfelds.",{"title":103,"searchDepth":104,"depth":104,"links":300},[301,302,303,304],{"id":222,"depth":107,"text":223},{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Umsetzung von Pong, dem Pionier der Videospielgeschichte. Entwickelt in C++ mit der SFML-Bibliothek, lag der Schwerpunkt hier auf der präzisen Berechnung von Reflexionsphysik, der Implementierung einer einfachen KI und der Synchronisation von Spielzuständen.",{"image":307,"video":308,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":309,"buildsystem":120,"downloads":310,"tags":313},"/games/pong/images/pong.png","/portfolioSite/games/pong/videos/pong.mp4","https://github.com/jjmercado/Pong",{"windows":311,"linux":312},"/downloads/Pong.zip","/downloads/Pong.tar.gz",[117,116],"/games/pong",{"title":217,"description":305},"games/pong","OvBwtZoRKAJ49iikGYVDPMen8z2gyCnbdklzvZHWEic",{"id":319,"title":320,"body":321,"description":387,"extension":112,"meta":388,"navigation":125,"path":396,"seo":397,"stem":398,"__hash__":399},"games/games/snake-classic.md","Snake Classic",{"type":8,"value":322,"toc":381},[323,327,330,332,335,346,348,365,367],[11,324,326],{"id":325},"projektbeschreibung-snake","Projektbeschreibung: Snake",[16,328,329],{},"Dieses Projekt ist meine Umsetzung des legendären Arcade-Klassikers Snake, entwickelt in C++ mit der SFML-Bibliothek. Das Ziel des Projekts war die Implementierung einer dynamischen Listen-Logik und eines grid-basierten Bewegungssystems, um die klassischen Gameplay-Mechaniken originalgetreu nachzubilden.",[11,331,22],{"id":21},[16,333,334],{},"Der Spieler steuert eine Schlange durch ein zweidimensionales Spielfeld. Mit jedem aufgenommenen Item wächst die Schlange, was die Navigation zunehmend erschwert. Die Kernmechaniken umfassen:",[27,336,337,340,343],{},[30,338,339],{},"Grid-Movement: Die Schlange bewegt sich in festen Schritten auf einem Gitter, wobei die Richtung nur um 90 Grad geändert werden kann.",[30,341,342],{},"Wachstums-Logik: Jedes Mal, wenn der Kopf der Schlange mit einem Futter-Objekt kollidiert, wird ein neues Segment am Ende angehängt.",[30,344,345],{},"Neustart: Das Spiel endet nicht es startet immer wieder neu, sobald der Kopf die Spielfeldbegrenzung berührt oder mit dem eigenen Körper kollidiert (Self-Collision).",[11,347,46],{"id":45},[27,349,350],{},[30,351,352,353,355,356,358,359,361,362,364],{},"Schlange: Taste ",[56,354,58],{}," (hoch), ",[56,357,172],{}," (runter), ",[56,360,62],{}," (links) und ",[56,363,66],{}," (rechts)",[11,366,75],{"id":74},[27,368,369,372,375,378],{},[30,370,371],{},"Datenstrukturen: Effiziente Verwaltung der Schlangensegmente, um das Nachrücken der Glieder performant zu berechnen.",[30,373,374],{},"Grid-basierte Kollisionserkennung: Prüfung der Positionen auf dem Koordinatensystem zur Erkennung von Treffern (Kopf vs. Futter oder Kopf vs. Körper).",[30,376,377],{},"Randomized Spawning: Algorithmus zur Platzierung von Futter auf freien Feldern, die nicht vom Körper der Schlange besetzt sind.",[30,379,380],{},"Frame-Rate Independent Logic: Trennung von Spielgeschwindigkeit (Tick-Rate) und Rendering, um die Schlangengeschwindigkeit unabhängig von der Bildwiederholrate zu steuern.",{"title":103,"searchDepth":104,"depth":104,"links":382},[383,384,385,386],{"id":325,"depth":107,"text":326},{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Snake, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken des Spiels von Grund auf zu programmieren.",{"image":389,"video":390,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":391,"buildsystem":120,"downloads":392,"tags":395},"/games/snake-classic/images/snake-classic.png","/portfolioSite/games/snake-classic/videos/snake-classic.mp4","https://github.com/jjmercado/Snake_classic",{"windows":393,"linux":394},"/downloads/SnakeApp.zip","/downloads/SnakeApp.tar.gz",[117,116],"/games/snake-classic",{"title":320,"description":387},"games/snake-classic","o17kbn-_fcHmRKb5gTC5MCBD7D4t3DxZATqBJqmU76I",[401,493,559],{"id":402,"title":403,"body":404,"date":484,"description":485,"extension":112,"meta":486,"navigation":125,"path":489,"seo":490,"stem":491,"__hash__":492},"polyslayer/devlog/polyslayer/retopoWarrior.md","Warrior Retopo",{"type":8,"value":405,"toc":480},[406,411,418,422,429],[407,408,410],"h1",{"id":409},"devlog-4-das-retopology-des-hauptcharakters","Devlog #4: Das Retopology des Hauptcharakters",[16,412,413,414,417],{},"Nachdem das High-Poly-Sculpting abgeschlossen ist, stand in den letzten Tagen ein entscheidender Schritt an: das ",[33,415,416],{},"Retopology",". Ziel war es, die Millionen von Polygonen in ein sauberes, performantes Mesh zu verwandeln, das bereit für Rigging und Animationen in Blender ist.",[11,419,421],{"id":420},"der-fokus-auf-die-details","Der Fokus auf die Details",[16,423,424,425,428],{},"Begonnen habe ich mit den komplexesten Bereichen. Da ich den Prozess von vielen Vertices zu weniger einfacher finde, habe ich mit den ",[33,426,427],{},"Ohren, der Nase und dem restlichen Kopf"," gestartet, um einen sauberen Edge-Flow zu garantieren.",[430,431,434,437,441,448],"nuxt-img",{"src":432,"alt":433},"/games/polyslayer/images/retopo/char/mainChar_retopo - 1.png","Retopo Char Ears",[435,436],"hr",{},[11,438,440],{"id":439},"von-den-extremitäten-zum-core","Von den Extremitäten zum Core",[16,442,443,444,447],{},"Nach dem Kopf folgte der Hals als Übergang zum Torso. Ein weiterer kritischer Punkt waren die ",[33,445,446],{},"Hände",". Da der Warrior später sein Schwert fest im Griff haben muss, ist hier eine präzise Topologie wichtig, um unschöne Verformungen beim Greifen zu vermeiden.",[430,449,452,454,458,461],{"src":450,"alt":451},"/games/polyslayer/images/retopo/char/mainChar_retopo - 2.png","Retopo Char Hands",[435,453],{},[11,455,457],{"id":456},"den-körper-schließen","Den Körper schließen",[16,459,460],{},"Vom Oberkörper aus habe ich das Mesh nach unten hin vervollständigt und schließlich auf die Beine aufgesplittet. Hier lag der Fokus besonders auf den Gelenken (Knie und Hüfte), um genügend \"Loops\" für saubere Deformationen beim Laufen und Kämpfen zu haben.",[430,462,465,467,471,474],{"src":463,"alt":464},"/games/polyslayer/images/retopo/char/mainChar_retopo - 3.png","Retopo Char Body",[435,466],{},[11,468,470],{"id":469},"das-ergebnis","Das Ergebnis",[16,472,473],{},"Das fertige Modell ist nun bereit für den nächsten Schritt. Im Vergleich zum massiven Sculpting-Modell ist es jetzt leichtgewichtig und perfekt für die Echtzeit-Berechnung optimiert.",[475,476,478],"video",{"loop":125,"autoPlay":125,"src":477},"/portfolioSite/games/polyslayer/videos/finishedRetopoMainChar.mp4",[435,479],{},{"title":103,"searchDepth":104,"depth":104,"links":481},[482,483],{"id":420,"depth":107,"text":421},{"id":439,"depth":107,"text":440},"2025-02-04T00:00:00.000Z","Der Prozess der Retopology: Optimierung des Hauptcharakters für maximale Performance.",{"project":487,"project_image":488},"PolySlayer","/games/polyslayer/images/thirdCharacter.png","/devlog/polyslayer/retopowarrior",{"title":403,"description":485},"devlog/polyslayer/retopoWarrior","5amYG4JARSTDtfbv-Z56eJ_Z63PLGZ-Wae21PTZZn1s",{"id":494,"title":495,"body":496,"date":551,"description":552,"extension":112,"meta":553,"navigation":125,"path":555,"seo":556,"stem":557,"__hash__":558},"polyslayer/devlog/polyslayer/erläuterung.md","Erläuterung",{"type":8,"value":497,"toc":548},[498,502,504,508,513,516,519,522,543,546],[407,499,501],{"id":500},"devlog-3-was-ist-alles-passiert","Devlog #3: Was ist alles passiert",[435,503],{},[11,505,507],{"id":506},"die-letzten-6-monate","Die letzten 6 Monate",[16,509,510],{},[33,511,512],{},"Vom Code-Enthusiasten zum Godot-User: Mein 2025 in der Spieleentwicklung",[16,514,515],{},"Eigentlich wollte ich Ende 2025 schon eine fertige Kampf-Demo präsentieren. Spoiler: Hat nicht ganz geklappt – aber aus den besten Gründen!",[16,517,518],{},"Nachdem mir Unity mit ihrem \"Cloud-Zwang\" und der unsicheren Preispolitik den letzten Nerv geraubt hat, bin ich komplett auf Godot umgestiegen. Ja, ich liebe C++ und hätte fast alles selbst programmiert, aber ich will ein Spiel fertigstellen und keine Engine-Entwicklungs-Odyssee starten.",[16,520,521],{},"Die letzten Monate waren ein riesiges Experimentierfeld:",[523,524,525,531,537],"ol",{},[30,526,527,530],{},[33,528,529],{},"Blender-Pipeline:"," Modelle, Häuser und Waffen exportieren, bis der Workflow sitzt.",[30,532,533,536],{},[33,534,535],{},"Leben in der Bude:"," Pathfinding für Wölfe und Hasen implementiert.",[30,538,539,542],{},[33,540,541],{},"Visuals:"," Shader-Spielereien und Partikeleffekte für leuchtende Schwerter.",[16,544,545],{},"Es hat länger gedauert als geplant, aber das Gelernte ist Gold wert. Sobald die überarbeitenden Modelle fertig sind, in diesem Fall der Warrior und als Gegner entweder ein Wolf oder einen Drachen, sowie die Animationen, bin ich bereit für das Kampfsystem!",[435,547],{},{"title":103,"searchDepth":104,"depth":104,"links":549},[550],{"id":506,"depth":107,"text":507},"2025-01-31T00:00:00.000Z","Was ist in den letzten 6 Monaten passiert",{"project":487,"project_image":554},"/games/polyslayer/images/placeholder.png","/devlog/polyslayer/erlauterung",{"title":495,"description":552},"devlog/polyslayer/erläuterung","RozJ7nGjt0ehbRwkKGKfcMff4L-M3iPpm3Xnf-83wlw",{"id":560,"title":561,"body":562,"date":697,"description":698,"extension":112,"meta":699,"navigation":125,"path":700,"seo":701,"stem":702,"__hash__":703},"polyslayer/devlog/polyslayer/statusQuo.md","Status-Quo",{"type":8,"value":563,"toc":693},[564,568,570,576,587,592,603,608,618,623,633,635,641,668,672,691],[407,565,567],{"id":566},"devlog-2-ein-vergleich","Devlog #2: Ein Vergleich",[435,569],{},[11,571,573],{"id":572},"teil-1-die-charakter-evolution",[33,574,575],{},"Teil 1: Die Charakter-Evolution",[27,577,578],{},[30,579,580,583],{},[33,581,582],{},"Bild 1: „Stunde Null: Der blaue Schwert-Prototyp“",[430,584],{"src":585,"alt":586},"/games/polyslayer/images/firstCharacter.png","firstCharacter",[27,588,589],{},[30,590,591],{},"Mein erster Entwurf! Hier ging es vor allem darum, den Workflow reinzukriegen und ein Gefühl für die Pipeline zu entwickeln.",[27,593,594],{},[30,595,596,599],{},[33,597,598],{},"Bild 2 „Level Up: Das neue Design mit Helm & Rüstung“",[430,600],{"src":601,"alt":602},"/games/polyslayer/images/secondCharacter.png","secondCharacter",[27,604,605],{},[30,606,607],{},"Back to the roots. Ich wollte unbedingt mehr in die Chibi-Richtung gehen – das war die Basis für den Look, den ich eigentlich im Kopf hatte.",[27,609,610],{},[30,611,612,615],{},[33,613,614],{},"Bild 3 „Level Up: Das aktuelle Design“",[430,616],{"src":488,"alt":617},"thirdCharacter",[27,619,620],{},[30,621,622],{},"Der „Sweet Spot“. Eine schlankere Mischung aus V1 und V2. Das ist momentan mein absoluter Favorit und die finale Basis für die nächsten Schritte!",[27,624,625],{},[30,626,627,630],{},[33,628,629],{},"Video „In Action: Schwertschwung“",[475,631],{"loop":125,"autoPlay":125,"src":632},"/portfolioSite/games/polyslayer/videos/version2Character.mp4",[435,634],{},[11,636,638],{"id":637},"teil-2-die-verwandlung-der-welt",[33,639,640],{},"Teil 2: Die Verwandlung der Welt",[27,642,643,651,659],{},[30,644,645,648],{},[33,646,647],{},"Video „Ein Blick zurück: Die alte Umgebung“",[475,649],{"loop":125,"autoPlay":125,"src":650},"/portfolioSite/games/polyslayer/videos/oldWorld.mp4",[30,652,653,656],{},[33,654,655],{},"Video „Erste Schritte: Orientierung in der Ur-Map“",[475,657],{"loop":125,"autoPlay":125,"src":658},"/portfolioSite/games/polyslayer/videos/oldWorldWalk.mp4",[30,660,661,664],{},[33,662,663],{},"Bild 3 „Vogelperspektive: Die erste Dorf-Planung“",[430,665],{"src":666,"alt":667},"/games/polyslayer/images/viewOfTown.png","viewoftown",[27,669,670],{},[30,671],{},[27,673,674,683],{},[30,675,676,679],{},[33,677,678],{},"Bild 4 „Details im Fokus: Brunnen, Windmühle & Fachwerk“",[430,680],{"src":681,"alt":682},"/games/polyslayer/images/viewOfTownNear.png","viewoftownnear",[30,684,685,688],{},[33,686,687],{},"Video „Parkour im Dorf: Das neue Spielgefühl“",[475,689],{"loop":125,"autoPlay":125,"src":690},"/portfolioSite/games/polyslayer/videos/newWorldWalk.mp4",[435,692],{},{"title":103,"searchDepth":104,"depth":104,"links":694},[695,696],{"id":572,"depth":107,"text":575},{"id":637,"depth":107,"text":640},"2025-01-30T00:00:00.000Z","Ein kleiner Eindruck was bereits geschaffen wurde",{"project":487,"project_image":554},"/devlog/polyslayer/statusquo",{"title":561,"description":698},"devlog/polyslayer/statusQuo","onQi0s8rsS1aVajYvIoXSpR7kqCRF0Jb7GXNloGRdwI",1770304849939]