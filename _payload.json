[{"data":1,"prerenderedAt":934},["ShallowReactive",2],{"games-list":3,"latest-posts-polyslayer":400},[4,130,215,318],{"id":5,"title":6,"body":7,"description":111,"extension":112,"meta":113,"navigation":125,"path":126,"seo":127,"stem":128,"__hash__":129},"games/games/asteroids.md","Asteroids",{"type":8,"value":9,"toc":102},"minimark",[10,15,19,23,26,43,47,50,72,76],[11,12,14],"h3",{"id":13},"projektbeschreibung-asteroids","Projektbeschreibung: Asteroids",[16,17,18],"p",{},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek (Simple and Fast Multimedia Library). Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.",[11,20,22],{"id":21},"das-spielprinzip","Das Spielprinzip",[16,24,25],{},"Der Spieler steuert ein dreieckiges Raumschiff in einem zweidimensionalen Asteroidenfeld. Die Besonderheit liegt in der Steuerung und der Physik:",[27,28,29,37],"ul",{},[30,31,32,36],"li",{},[33,34,35],"strong",{},"Wrapping-World:"," Objekte, die den Bildschirmrand verlassen, erscheinen auf der gegenüberliegenden Seite wieder (Screen Wrapping).",[30,38,39,42],{},[33,40,41],{},"Zerstörung:"," Große Asteroiden zerfallen bei Treffern in kleinere, schnellere Fragmente.",[11,44,46],{"id":45},"steuerung","Steuerung",[16,48,49],{},"Das Spiel ist für zwei Spieler an einer Tastatur konzipiert:",[27,51,52],{},[30,53,54,55,59,60,63,64,67,68,71],{},"Raumschiff: Taste ",[56,57,58],"kbd",{},"W"," (vorwärts), ",[56,61,62],{},"A"," (links Rotieren), ",[56,65,66],{},"D"," (rechts Rotieren) und ",[56,69,70],{},"Leertaste"," (schießen)",[11,73,75],{"id":74},"technische-highlights-features","Technische Highlights & Features",[27,77,78,84,90,96],{},[30,79,80,83],{},[33,81,82],{},"Vektorphysik:"," Berechnung Rotation und Geschwindigkeit basierend auf vektorieller Mathematik.",[30,85,86,89],{},[33,87,88],{},"Kollisionserkennung:"," Implementierung von Hitboxen, um Interaktionen zwischen Geschossen, Asteroiden und dem Schiff zu prüfen.",[30,91,92,95],{},[33,93,94],{},"Game Loop:"," Ein sauberer Game-Loop zur Trennung von Input-Verarbeitung, Logik-Update und Rendering.",[30,97,98,101],{},[33,99,100],{},"Ressourcenmanagement:"," Laden und Verwalten von Texturen über SFML.",{"title":103,"searchDepth":104,"depth":104,"links":105},"",2,[106,108,109,110],{"id":13,"depth":107,"text":14},3,{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.","md",{"image":114,"video":115,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":119,"buildsystem":120,"downloads":121,"tags":124},"/games/asteroids/images/Asteroids.png","/portfolioSite/games/asteroids/videos/Asteroids.mp4","SFML","C++","ca. 1 Monate","https://github.com/jjmercado/Asteroids","CMake",{"windows":122,"linux":123},"/downloads/Asteroids.zip","/downloads/Asteroids.tar.gz",[117,116],true,"/games/asteroids",{"title":6,"description":111},"games/asteroids","coAGsGGZuAGg8ITTcNAFhU_oud1zDT4ZBNkdt1bTp0E",{"id":131,"title":132,"body":133,"description":141,"extension":112,"meta":202,"navigation":125,"path":211,"seo":212,"stem":213,"__hash__":214},"games/games/pac-man.md","Pac-Man",{"type":8,"value":134,"toc":196},[135,139,142,144,147,158,160,162,180,182],[11,136,138],{"id":137},"projektbeschreibung-pac-man","Projektbeschreibung: Pac-Man",[16,140,141],{},"Dieses Projekt ist meine Implementierung des zeitlosen Arcade-Hits Pac-Man, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Der Fokus lag hierbei auf der Umsetzung komplexer Pfadfindungs-Algorithmen und einer kachel-basierten (Tile-based) Weltlogik.",[11,143,22],{"id":21},[16,145,146],{},"Der Spieler steuert Pac-Man durch ein Labyrinth, mit dem Ziel, alle Punkte (Pellets) zu fressen, während er vier Geistern ausweicht. Das Gameplay zeichnet sich durch folgende Mechaniken aus:",[27,148,149,152,155],{},[30,150,151],{},"Tile-Based Navigation: Die gesamte Welt besteht aus einem Raster, das die Bewegung einschränkt und die Kollision mit Wänden definiert.",[30,153,154],{},"Power-Pellets: Das Einsammeln spezieller Items kehrt die Rollen kurzzeitig um, sodass Pac-Man die Geister fressen kann.",[30,156,157],{},"Warp-Tunnel: Seitliche Ausgänge, die den Spieler sofort auf die gegenüberliegende Seite des Spielfelds transportieren.",[11,159,46],{"id":45},[16,161,49],{},[27,163,164],{},[30,165,166,167,169,170,173,174,176,177,179],{},"Pac-Man: Tasten ",[56,168,58],{}," (Hoch), ",[56,171,172],{},"S"," (Runter), ",[56,175,62],{}," (Links), ",[56,178,66],{}," (Rechts)",[11,181,75],{"id":74},[27,183,184,187,190,193],{},[30,185,186],{},"Wegfindungs-KI: Die Wegfindung basiert auf \"Schildern\" die an den Kreuzungen stehen und\neine zufällige Auswahl an Wegen, nach Kreuzung, bietet.",[30,188,189],{},"State-Machine: Steuerung der verschiedenen Zustände von Pac-Man und den Geistern (Chase, Scatter, Frightened).",[30,191,192],{},"Tilemap-System: Effizientes Rendering des Labyrinths durch eine Tilemap, bei der die Map-Daten aus einem Array geladen werden.",[30,194,195],{},"Animations-System: Sprite-Sheet-Animationen für das Öffnen/Schließen des Mundes von Pac-Man.",{"title":103,"searchDepth":104,"depth":104,"links":197},[198,199,200,201],{"id":137,"depth":107,"text":138},{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},{"image":203,"video":204,"gif":103,"engine":103,"framework":116,"language":117,"devtime":205,"githubLink":206,"buildsystem":120,"downloads":207,"tags":210},"/games/pac-man/images/pac-man.png","/portfolioSite/games/pac-man/videos/pac-man.mp4","ca. 3 Monate","https://github.com/jjmercado/Pac-Man",{"windows":208,"linux":209},"/downloads/PacMan.zip","/downloads/PacMan.tar.gz",[117,116],"/games/pac-man",{"title":132,"description":141},"games/pac-man","BEpJYdRm-p7gze6VJMWzsLX-vEs5HYNKNAUJjMisxVc",{"id":216,"title":217,"body":218,"description":305,"extension":112,"meta":306,"navigation":125,"path":314,"seo":315,"stem":316,"__hash__":317},"games/games/pong.md","Pong",{"type":8,"value":219,"toc":299},[220,224,227,229,232,252,254,256,277,279],[11,221,223],{"id":222},"projektbeschreibung-pong","Projektbeschreibung: Pong",[16,225,226],{},"Dieses Projekt ist meine Umsetzung des Arcade-Klassikers Pong, ausgelegt als lokales 2-Spieler-Spiel. Entwickelt in C++ mit der SFML-Bibliothek, bietet es eine solide Basis, die gerne erweitert werden kann.",[11,228,22],{"id":21},[16,230,231],{},"Pong simuliert ein Tischtennis-Duell. Der Ball prallt von Wänden und Paddles ab.",[27,233,234,240,246],{},[30,235,236,239],{},[33,237,238],{},"Reflexions-Gameplay:"," Der Ball prallt von den oberen und unteren Begrenzungen sowie von den Spieler-Paddles ab.",[30,241,242,245],{},[33,243,244],{},"Punktesystem:"," Ein Punkt wird vergeben, wenn der Ball die hintere Spielfeldbegrenzung eines Spielers überschreitet. Das Spiel endet nach Erreichen einer vordefinierten Punktzahl.",[30,247,248,251],{},[33,249,250],{},"Game-Loop:"," Saubere Trennung von Input, Spiellogik und Rendering für flüssiges Gameplay.",[11,253,46],{"id":45},[16,255,49],{},[27,257,258,267],{},[30,259,260,261,263,264,266],{},"Linker Spieler: Tasten ",[56,262,58],{}," (hoch) und ",[56,265,172],{}," (runter)",[30,268,269,270,273,274],{},"Rechter Spieler: Pfeiltasten ",[56,271,272],{},"Oben"," und ",[56,275,276],{},"Unten",[11,278,75],{"id":74},[27,280,281,287,293],{},[30,282,283,286],{},[33,284,285],{},"Vektor-Reflexion:"," Mathematische Berechnung der Abprallwinkel. Die Flugbahn wird manipuliert, je nachdem, an welcher Stelle des Paddles der Ball auftrifft (Steilerer Winkel bei Treffern an den Kanten).",[30,288,289,292],{},[33,290,291],{},"AABB-Kollisionserkennung:"," Implementierung von Axis-Aligned Bounding Boxes zur schnellen und zuverlässigen Erkennung von Kollisionen zwischen Ball, Wänden und Paddles.",[30,294,295,298],{},[33,296,297],{},"UI & Scoring-System:"," Dynamische Anzeige des Spielstands mittels SFML-Text-Komponenten und Echtzeit-Aktualisierung des Spielfelds.",{"title":103,"searchDepth":104,"depth":104,"links":300},[301,302,303,304],{"id":222,"depth":107,"text":223},{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Umsetzung von Pong, dem Pionier der Videospielgeschichte. Entwickelt in C++ mit der SFML-Bibliothek, lag der Schwerpunkt hier auf der präzisen Berechnung von Reflexionsphysik, der Implementierung einer einfachen KI und der Synchronisation von Spielzuständen.",{"image":307,"video":308,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":309,"buildsystem":120,"downloads":310,"tags":313},"/games/pong/images/pong.png","/portfolioSite/games/pong/videos/pong.mp4","https://github.com/jjmercado/Pong",{"windows":311,"linux":312},"/downloads/Pong.zip","/downloads/Pong.tar.gz",[117,116],"/games/pong",{"title":217,"description":305},"games/pong","OvBwtZoRKAJ49iikGYVDPMen8z2gyCnbdklzvZHWEic",{"id":319,"title":320,"body":321,"description":387,"extension":112,"meta":388,"navigation":125,"path":396,"seo":397,"stem":398,"__hash__":399},"games/games/snake-classic.md","Snake Classic",{"type":8,"value":322,"toc":381},[323,327,330,332,335,346,348,365,367],[11,324,326],{"id":325},"projektbeschreibung-snake","Projektbeschreibung: Snake",[16,328,329],{},"Dieses Projekt ist meine Umsetzung des legendären Arcade-Klassikers Snake, entwickelt in C++ mit der SFML-Bibliothek. Das Ziel des Projekts war die Implementierung einer dynamischen Listen-Logik und eines grid-basierten Bewegungssystems, um die klassischen Gameplay-Mechaniken originalgetreu nachzubilden.",[11,331,22],{"id":21},[16,333,334],{},"Der Spieler steuert eine Schlange durch ein zweidimensionales Spielfeld. Mit jedem aufgenommenen Item wächst die Schlange, was die Navigation zunehmend erschwert. Die Kernmechaniken umfassen:",[27,336,337,340,343],{},[30,338,339],{},"Grid-Movement: Die Schlange bewegt sich in festen Schritten auf einem Gitter, wobei die Richtung nur um 90 Grad geändert werden kann.",[30,341,342],{},"Wachstums-Logik: Jedes Mal, wenn der Kopf der Schlange mit einem Futter-Objekt kollidiert, wird ein neues Segment am Ende angehängt.",[30,344,345],{},"Neustart: Das Spiel endet nicht es startet immer wieder neu, sobald der Kopf die Spielfeldbegrenzung berührt oder mit dem eigenen Körper kollidiert (Self-Collision).",[11,347,46],{"id":45},[27,349,350],{},[30,351,352,353,355,356,358,359,361,362,364],{},"Schlange: Taste ",[56,354,58],{}," (hoch), ",[56,357,172],{}," (runter), ",[56,360,62],{}," (links) und ",[56,363,66],{}," (rechts)",[11,366,75],{"id":74},[27,368,369,372,375,378],{},[30,370,371],{},"Datenstrukturen: Effiziente Verwaltung der Schlangensegmente, um das Nachrücken der Glieder performant zu berechnen.",[30,373,374],{},"Grid-basierte Kollisionserkennung: Prüfung der Positionen auf dem Koordinatensystem zur Erkennung von Treffern (Kopf vs. Futter oder Kopf vs. Körper).",[30,376,377],{},"Randomized Spawning: Algorithmus zur Platzierung von Futter auf freien Feldern, die nicht vom Körper der Schlange besetzt sind.",[30,379,380],{},"Frame-Rate Independent Logic: Trennung von Spielgeschwindigkeit (Tick-Rate) und Rendering, um die Schlangengeschwindigkeit unabhängig von der Bildwiederholrate zu steuern.",{"title":103,"searchDepth":104,"depth":104,"links":382},[383,384,385,386],{"id":325,"depth":107,"text":326},{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Snake, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken des Spiels von Grund auf zu programmieren.",{"image":389,"video":390,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":391,"buildsystem":120,"downloads":392,"tags":395},"/games/snake-classic/images/snake-classic.png","/portfolioSite/games/snake-classic/videos/snake-classic.mp4","https://github.com/jjmercado/Snake_classic",{"windows":393,"linux":394},"/downloads/SnakeApp.zip","/downloads/SnakeApp.tar.gz",[117,116],"/games/snake-classic",{"title":320,"description":387},"games/snake-classic","o17kbn-_fcHmRKb5gTC5MCBD7D4t3DxZATqBJqmU76I",[401,554,748],{"id":402,"title":403,"body":404,"date":545,"description":546,"extension":112,"meta":547,"navigation":125,"path":550,"seo":551,"stem":552,"__hash__":553},"polyslayer/devlog/polyslayer/weightPaint.md","Weight Painting & Skinning: Wenn Metall auf Bewegung trifft",{"type":8,"value":405,"toc":538},[406,411,418,423,430,433,447,462,465,469,472,482,484,488,491,511,525,527,531],[407,408,410],"h1",{"id":409},"weight-painting-stabilität-trifft-flexibilität","Weight Painting – Stabilität trifft Flexibilität",[16,412,413,414,417],{},"Nachdem das Rig steht, folgt die Königsdisziplin: das ",[33,415,416],{},"Weight Painting",". Hier legen wir fest, welcher Knochen (Bone) welchen Teil des Modells wie stark beeinflusst. Die Herausforderung bei einer Rüstung? Ein Stiefel aus Stahl darf sich nicht so stark verbiegen wie ein Lederschuh.",[419,420,422],"h2",{"id":421},"harte-kanten-vs-knautschzonen","Harte Kanten vs. Knautschzonen",[16,424,425,426,429],{},"Im ersten Schritt weise ich den starren Ausrüstungsteilen ihre festen Gewichte zu. Ein Helm beispielsweise bekommt ein volles Weight (1.0) auf den ",[33,427,428],{},"Head-Socket",", damit er starr bleibt und nicht bei jeder Kopfbewegung \"wabbert\".",[16,431,432],{},"Bei anderen Teilen schauen wir genau hin:",[27,434,435,441],{},[30,436,437,440],{},[33,438,439],{},"Stiefel & Handschuhe:"," Diese müssen stabil wirken, aber an den Gelenken genug Flexibilität besitzen.",[30,442,443,446],{},[33,444,445],{},"Brust & Beine:"," Hier definieren wir bewusste \"Knautschzonen\". Es muss nicht physikalisch 100% korrekt sein, aber es muss im Spielverlauf glaubwürdig aussehen.",[27,448,449,456],{},[30,450,451],{},[452,453],"nuxt-img",{"src":454,"alt":455},"/games/polyslayer/images/weightpainting/helmet_socket_weightpaint.png","Helmet not weightpainted",[30,457,458],{},[452,459],{"src":460,"alt":461},"/games/polyslayer/images/weightpainting/helmet_weightpainted.png","Helmet weightpainted",[463,464],"hr",{},[419,466,468],{"id":467},"der-trick-mit-dem-schwert-und-den-sockets","Der Trick mit dem Schwert und den Sockets",[16,470,471],{},"Ein wichtiger Punkt für den Workflow: Das Schwert wird im Blender-File mitanimiert, damit ich die Bewegungsabläufe (wie Angriffe oder Ziehen der Waffe) perfekt beurteilen kann.",[16,473,474,477,478,481],{},[33,475,476],{},"Wichtig für den Export:","\nDas Schwert selbst wird beim finalen Export des Charakters weggelassen. Im Spiel wird es dynamisch über den Waffen-Socket zugewiesen. Das Gleiche gilt für die modulare Ausrüstung.\nEine Ausnahme bilden die ",[33,479,480],{},"Gauntlets (Handschuhe)",": Da wir hier die Fingerbewegungen benötigen, werden diese direkt mitanimiert, da im Spiel später die kompletten Hände inklusive Handschuh-Mesh ausgetauscht werden.",[463,483],{},[419,485,487],{"id":486},"iteratives-arbeiten-animation-als-härtetest","Iteratives Arbeiten: Animation als Härtetest",[16,489,490],{},"Mein Workflow ist hier zyklisch:",[492,493,494,499,505],"ol",{},[30,495,496,498],{},[33,497,416],{}," (Grob-Setup)",[30,500,501,504],{},[33,502,503],{},"Test-Animation"," (Angriff, Laufen, Idle)",[30,506,507,510],{},[33,508,509],{},"Fehlerkorrektur:"," Sobald in einer extremen Pose das Mesh unschön ineinander schiebt, kehre ich zum Weight Painting zurück und korrigiere die Einflüsse.",[27,512,513,519],{},[30,514,515],{},[452,516],{"src":517,"alt":518},"/games/polyslayer/images/weightpainting/test_pose_wp.png","Test Pose",[30,520,521],{},[452,522],{"src":523,"alt":524},"/games/polyslayer/images/weightpainting/test_pose_wp_shaded.png","Test Pose Shaded",[463,526],{},[11,528,530],{"id":529},"wie-geht-es-weiter","Wie geht es weiter?",[16,532,533,534,537],{},"Das Mesh folgt nun sauber dem Rig. Als Nächstes tauchen wir voll in die ",[33,535,536],{},"Animation"," ein, um PolySlayer seinen ganz eigenen Charakter zu verleihen!",{"title":103,"searchDepth":104,"depth":104,"links":539},[540,541,542],{"id":421,"depth":104,"text":422},{"id":467,"depth":104,"text":468},{"id":486,"depth":104,"text":487,"children":543},[544],{"id":529,"depth":107,"text":530},"2025-02-10T00:00:00.000Z","So meistern wir das Weight Painting in PolySlayer. Über Knautschzonen, starre Rüstungsteile und den korrekten Export für Sockets.",{"project":548,"project_image":549},"PolySlayer","/games/polyslayer/images/weightpainting_progress.png","/devlog/polyslayer/weightpaint",{"title":403,"description":546},"devlog/polyslayer/weightPaint","SNUNKOk43MLihBxx5OIMKjypfrKYBwomFurl_6I3WUU",{"id":555,"title":556,"body":557,"date":740,"description":741,"extension":112,"meta":742,"navigation":125,"path":744,"seo":745,"stem":746,"__hash__":747},"polyslayer/devlog/polyslayer/rigging.md","Rigging mit Rigify: Vom Mesh zum animierbaren Helden",{"type":8,"value":558,"toc":732},[559,563,573,577,580,594,603,617,621,624,644,646,650,661,693,696,704,706,710,713,721,723,725],[407,560,562],{"id":561},"das-rigging-den-charakter-zum-leben-erwecken","Das Rigging – Den Charakter zum Leben erwecken",[16,564,565,566,568,569,572],{},"Nachdem das Texturing abgeschlossen ist, wird es Zeit, dass sich unser Held auch bewegen kann. Für ",[33,567,548],{}," setzen wir auf das mächtige ",[33,570,571],{},"Rigify-Addon"," in Blender, um ein professionelles Human-Rig zu erstellen.",[419,574,576],{"id":575},"optimierung-des-rigs-weniger-ist-mehr","Optimierung des Rigs: Weniger ist mehr",[16,578,579],{},"Da unser Charakter einen stilisierten Look hat und wir keine komplexen Mimiken benötigen, haben wir das Rig direkt entschlackt. Alle Gesichtszüge (Face Bones) wurden entfernt, um das Rig sauber und performant zu halten.",[27,581,582,588],{},[30,583,584],{},[452,585],{"src":586,"alt":587},"/games/polyslayer/images/rigging/rigify_rig_delete_face.png","Delete Face Bones",[30,589,590],{},[452,591],{"src":592,"alt":593},"/games/polyslayer/images/rigging/rig_face_del.png","Deleted Face Bones",[595,596,597],"blockquote",{},[16,598,599,602],{},[33,600,601],{},"Pro-Tipp (Troubleshooting):"," Achtet darauf, wirklich alle Face-Bones zu erwischen! Oft versteckt sich ein winziger Bone im Kopf-Bereich. Wenn dieser bleibt, wirft Rigify beim Generieren oder Upgraden des Rigs eine Fehlermeldung aus.",[27,604,605,611],{},[30,606,607],{},[452,608],{"src":609,"alt":610},"/games/polyslayer/images/rigging/error_when_not_upgrade_face.png","Error Message",[30,612,613],{},[452,614],{"src":615,"alt":616},"/games/polyslayer/images/rigging/hidden_face_bone.png","Hidden Face Bone",[419,618,620],{"id":619},"vorsicht-bei-überlappenden-bones","Vorsicht bei überlappenden Bones",[16,622,623],{},"Ein weiterer Stolperstein beim Rigging in Blender sind überlappende Bones. Wenn man beim Editieren des Metarigs versehentlich Bones verschiebt, die exakt übereinander liegen sollten, quittiert Rigify das mit einem Error beim Generieren. Präzision im Edit-Mode ist hier das A und O.",[27,625,626,632,638],{},[30,627,628],{},[452,629],{"src":630,"alt":631},"/games/polyslayer/images/rigging/spine_not_overlapped.png","Spine not overlaped",[30,633,634],{},[452,635],{"src":636,"alt":637},"/games/polyslayer/images/rigging/spine_overlapped.png","Spine is overlapping",[30,639,640],{},[452,641],{"src":642,"alt":643},"/games/polyslayer/images/rigging/disjoint_error_message.png","Disjoint Error Message",[463,645],{},[419,647,649],{"id":648},"custom-sockets-für-modulare-ausrüstung","Custom Sockets für modulare Ausrüstung",[16,651,652,653,656,657,660],{},"Da PolySlayer verschiedene Rüstungsteile unterstützt, habe ich das Standard-Rig um ",[33,654,655],{},"Extra-Bones"," erweitert. Diese dienen als feste ",[33,658,659],{},"Sockets"," (Ankerpunkte) für unsere Ausrüstung:",[27,662,663,668,673,678,683,688],{},[30,664,665],{},[33,666,667],{},"Helm-Socket",[30,669,670],{},[33,671,672],{},"Waffen-Socket",[30,674,675],{},[33,676,677],{},"Schulter-Socket",[30,679,680],{},[33,681,682],{},"Schuhe-Socket",[30,684,685],{},[33,686,687],{},"Beine-Socket",[30,689,690],{},[33,691,692],{},"Brust- & Handschuh-Sockets",[16,694,695],{},"Dadurch können wir Rüstungsteile später im Spiel dynamisch austauschen, während sie perfekt an der Bewegung des Skeletts haften.",[27,697,698],{},[30,699,700],{},[452,701],{"src":702,"alt":703},"/games/polyslayer/images/rigging/char_meta_rig.png","Meta rig",[463,705],{},[419,707,709],{"id":708},"das-ergebnis-ein-einsatzbereites-rig","Das Ergebnis: Ein einsatzbereites Rig",[16,711,712],{},"Wenn alle Fehlerquellen beseitigt sind, generiert Rigify das finale Control-Rig. Dieses Skelett verbinden wir nun mit unserem Mesh – der Grundstein für alle kommenden Animationen ist damit gelegt!",[27,714,715],{},[30,716,717],{},[452,718],{"src":719,"alt":720},"/games/polyslayer/images/rigging/char_rig.png","Rig",[463,722],{},[11,724,530],{"id":529},[16,726,727,728,731],{},"Das Skelett steht! Im nächsten Schritt widmen wir uns dem ",[33,729,730],{},"Skinning und Weight Painting",", damit sich die Rüstung bei Bewegungen nicht unnatürlich verformt.",{"title":103,"searchDepth":104,"depth":104,"links":733},[734,735,736,737],{"id":575,"depth":104,"text":576},{"id":619,"depth":104,"text":620},{"id":648,"depth":104,"text":649},{"id":708,"depth":104,"text":709,"children":738},[739],{"id":529,"depth":107,"text":530},"2025-02-08T00:00:00.000Z","So nutzen wir das Rigify Addon in Blender für PolySlayer, inklusive Troubleshooting zu Face-Bones und Sockets.",{"project":548,"project_image":743},"/games/polyslayer/images/rigging_result.png","/devlog/polyslayer/rigging",{"title":556,"description":741},"devlog/polyslayer/rigging","5vGtrfzWusxCR-sjLhU_Nk-_3x-bsGopRNd5clNI5Fw",{"id":749,"title":750,"body":751,"date":927,"description":928,"extension":112,"meta":929,"navigation":125,"path":930,"seo":931,"stem":932,"__hash__":933},"polyslayer/devlog/polyslayer/texturing2.md","Ausrüstungs-Texturing: Die komplette Rüstung im Detail",{"type":8,"value":752,"toc":919},[753,757,767,770,774,781,783,787,794,798,801,859,867,871,874,883,891,893,895,898,901,904,907,910,913],[407,754,756],{"id":755},"das-texturing-update-die-rüstung-ist-bereit","Das Texturing-Update – Die Rüstung ist bereit!",[16,758,759,760,762,763,766],{},"Willkommen Devlog von ",[33,761,548],{},". Nachdem wir uns im letzten Schritt mit den Grundformen beschäftigt haben, geht es heute ans Eingemachte: Das komplette ",[33,764,765],{},"Texturing der Ausrüstung",".",[16,768,769],{},"In dieser Phase haben wir der gesamten Rüstung ihren finalen Look verliehen. Auch wenn das aktuelle Farbschema bereits gut funktioniert, halten wir uns die Option offen, die Farben im späteren Polishing-Prozess noch einmal feinabzustimmen, um sie perfekt an die Spielwelt anzupassen.",[419,771,773],{"id":772},"das-ergebnis-die-vollständige-rüstung","Das Ergebnis: Die vollständige Rüstung",[16,775,776,777],{},"Hier seht ihr den aktuellen Stand der Texturen. Der Fokus lag darauf, den Materialien wie Metall, Leder und Stoff eine eigene Identität zu geben, damit die Rüstung trotz des Low-Poly-Stils hochwertig und \"griffig\" wirkt.\n",[452,778],{"src":779,"alt":780},"/games/polyslayer/images/texturing/texturing_result.png","PolySlayer Character Armor Texturing Result",[463,782],{},[419,784,786],{"id":785},"der-normal-map-effekt-details-ohne-performance-verlust","Der \"Normal Map\"-Effekt: Details ohne Performance-Verlust",[16,788,789,790,793],{},"Ein entscheidender Teil unseres Workflows ist die Nutzung von ",[33,791,792],{},"Normal Maps",". Um zu verdeutlichen, wie viel Tiefe diese Technik dem Spiel verleiht, haben wir einen direkten Vergleich vorbereitet. Die Normal Map \"faked\" das Licht auf der Oberfläche und lässt das Low-Poly-Modell so detailliert wie das High-Poly-Original aussehen.",[11,795,797],{"id":796},"performance-check-high-poly-vs-low-poly","Performance-Check: High-Poly vs. Low-Poly",[16,799,800],{},"Der Unterschied in der Optimierung ist gewaltig. Durch das \"Baken\" der Details sparen wir Millionen von Polygonen, was die Performance massiv steigert:",[802,803,804,821],"table",{},[805,806,807],"thead",{},[808,809,810,815,818],"tr",{},[811,812,814],"th",{"align":813},"left","Version",[811,816,817],{"align":813},"Triangle Count",[811,819,820],{"align":813},"Status",[822,823,824,842],"tbody",{},[808,825,826,832,837],{},[827,828,829],"td",{"align":813},[33,830,831],{},"High-Poly Modell",[827,833,834],{"align":813},[33,835,836],{},"~ 5.637.000",[827,838,839],{"align":813},[33,840,841],{},"Unspielbar (nur für Details)",[808,843,844,849,854],{},[827,845,846],{"align":813},[33,847,848],{},"Low-Poly Modell",[827,850,851],{"align":813},[33,852,853],{},"26.906",[827,855,856],{"align":813},[33,857,858],{},"Optimiert für Gameplay",[595,860,861],{},[16,862,863,866],{},[33,864,865],{},"Der Clou:"," Dank der Normal Map sieht das 26k-Modell im Spiel fast identisch zum 5,6-Millionen-Modell aus.",[11,868,870],{"id":869},"videovergleich-mit-vs-ohne-normal-map","Videovergleich: Mit vs. Ohne Normal Map",[16,872,873],{},"Hier seht ihr das Schwert und die Rüstung im direkten Vergleich. Achtet darauf, wie das Licht ohne Normal Map flach wirkt und mit Normal Map plötzlich jede Scharte und Kante betont wird.",[16,875,876,879],{},[33,877,878],{},"Ohne Normal Map (Flaches Mesh):",[880,881],"video",{"loop":125,"autoPlay":125,"muted":125,"playsInline":125,"src":882},"/portfolioSite/games/polyslayer/videos/result_texturing_without_normal.mp4",[16,884,885,888],{},[33,886,887],{},"Mit Normal Map (Full Detail):",[880,889],{"loop":125,"autoPlay":125,"muted":125,"playsInline":125,"src":890},"/portfolioSite/games/polyslayer/videos/result_texturing_with_normal.mp4",[463,892],{},[11,894,530],{"id":529},[16,896,897],{},"Nachdem die Ausrüstung nun steht, rückt das Rigging und die Animation näher. Bleibt dran für das nächste Update!",[16,899,900],{},"⚡ Update: Entscheidung für mehr Flexibilität",[16,902,903],{},"Während der Arbeit an den Texturen habe ich mich für eine wichtige Änderung im Workflow entschieden:",[16,905,906],{},"Anstatt alle Rüstungsteile fest auf eine einzige, statische Textur-Map zu binden, steuere ich die Teile nun individuell über das Material in der Engine an.",[16,908,909],{},"Warum dieser Nachtrag? Ursprünglich war ein festes Farbschema für das Set geplant. Mir wurde jedoch klar, dass dies die Möglichkeiten einschränkt. Durch die Umstellung auf Material-Instanzen habe ich nun die Freiheit, die Farbwerte direkt in der Engine anzupassen.",[16,911,912],{},"Das Ziel ist es, euch später im Spiel eine Auswahl an verschiedenen Farbvarianten anzubieten. So könnt ihr eure Ausrüstung aus einem Set an vordefinierten Farben individualisieren – ein Feature, das mit dem alten, statischen Workflow extrem aufwendig umzusetzen gewesen wäre.",[16,914,915,916],{},"Hier seht ihr den Test der verschiedenen Farb-Presets:\n",[880,917],{"loop":125,"autoPlay":125,"muted":125,"playsInline":125,"src":918},"/portfolioSite/games/polyslayer/videos/material_color_update.mp4",{"title":103,"searchDepth":104,"depth":104,"links":920},[921,922],{"id":772,"depth":104,"text":773},{"id":785,"depth":104,"text":786,"children":923},[924,925,926],{"id":796,"depth":107,"text":797},{"id":869,"depth":107,"text":870},{"id":529,"depth":107,"text":530},"2025-02-06T00:00:00.000Z","Wie wir über 5 Millionen Polygone in 26k Triangles backen – Texturing und Normal Maps bei PolySlayer.",{"project":548,"project_image":779},"/devlog/polyslayer/texturing2",{"title":750,"description":928},"devlog/polyslayer/texturing2","l8qxgD8xE601Xewr5oVpAbtM8v3f1G-tliPJ9UJWpFE",1770804220500]