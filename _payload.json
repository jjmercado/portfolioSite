[{"data":1,"prerenderedAt":801},["ShallowReactive",2],{"games-list":3,"latest-posts-polyslayer":400},[4,130,215,318],{"id":5,"title":6,"body":7,"description":111,"extension":112,"meta":113,"navigation":125,"path":126,"seo":127,"stem":128,"__hash__":129},"games/games/asteroids.md","Asteroids",{"type":8,"value":9,"toc":102},"minimark",[10,15,19,23,26,43,47,50,72,76],[11,12,14],"h3",{"id":13},"projektbeschreibung-asteroids","Projektbeschreibung: Asteroids",[16,17,18],"p",{},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek (Simple and Fast Multimedia Library). Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.",[11,20,22],{"id":21},"das-spielprinzip","Das Spielprinzip",[16,24,25],{},"Der Spieler steuert ein dreieckiges Raumschiff in einem zweidimensionalen Asteroidenfeld. Die Besonderheit liegt in der Steuerung und der Physik:",[27,28,29,37],"ul",{},[30,31,32,36],"li",{},[33,34,35],"strong",{},"Wrapping-World:"," Objekte, die den Bildschirmrand verlassen, erscheinen auf der gegenüberliegenden Seite wieder (Screen Wrapping).",[30,38,39,42],{},[33,40,41],{},"Zerstörung:"," Große Asteroiden zerfallen bei Treffern in kleinere, schnellere Fragmente.",[11,44,46],{"id":45},"steuerung","Steuerung",[16,48,49],{},"Das Spiel ist für zwei Spieler an einer Tastatur konzipiert:",[27,51,52],{},[30,53,54,55,59,60,63,64,67,68,71],{},"Raumschiff: Taste ",[56,57,58],"kbd",{},"W"," (vorwärts), ",[56,61,62],{},"A"," (links Rotieren), ",[56,65,66],{},"D"," (rechts Rotieren) und ",[56,69,70],{},"Leertaste"," (schießen)",[11,73,75],{"id":74},"technische-highlights-features","Technische Highlights & Features",[27,77,78,84,90,96],{},[30,79,80,83],{},[33,81,82],{},"Vektorphysik:"," Berechnung Rotation und Geschwindigkeit basierend auf vektorieller Mathematik.",[30,85,86,89],{},[33,87,88],{},"Kollisionserkennung:"," Implementierung von Hitboxen, um Interaktionen zwischen Geschossen, Asteroiden und dem Schiff zu prüfen.",[30,91,92,95],{},[33,93,94],{},"Game Loop:"," Ein sauberer Game-Loop zur Trennung von Input-Verarbeitung, Logik-Update und Rendering.",[30,97,98,101],{},[33,99,100],{},"Ressourcenmanagement:"," Laden und Verwalten von Texturen über SFML.",{"title":103,"searchDepth":104,"depth":104,"links":105},"",2,[106,108,109,110],{"id":13,"depth":107,"text":14},3,{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.","md",{"image":114,"video":115,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":119,"buildsystem":120,"downloads":121,"tags":124},"/games/asteroids/images/Asteroids.png","/portfolioSite/games/asteroids/videos/Asteroids.mp4","SFML","C++","ca. 1 Monate","https://github.com/jjmercado/Asteroids","CMake",{"windows":122,"linux":123},"/downloads/Asteroids.zip","/downloads/Asteroids.tar.gz",[117,116],true,"/games/asteroids",{"title":6,"description":111},"games/asteroids","coAGsGGZuAGg8ITTcNAFhU_oud1zDT4ZBNkdt1bTp0E",{"id":131,"title":132,"body":133,"description":141,"extension":112,"meta":202,"navigation":125,"path":211,"seo":212,"stem":213,"__hash__":214},"games/games/pac-man.md","Pac-Man",{"type":8,"value":134,"toc":196},[135,139,142,144,147,158,160,162,180,182],[11,136,138],{"id":137},"projektbeschreibung-pac-man","Projektbeschreibung: Pac-Man",[16,140,141],{},"Dieses Projekt ist meine Implementierung des zeitlosen Arcade-Hits Pac-Man, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Der Fokus lag hierbei auf der Umsetzung komplexer Pfadfindungs-Algorithmen und einer kachel-basierten (Tile-based) Weltlogik.",[11,143,22],{"id":21},[16,145,146],{},"Der Spieler steuert Pac-Man durch ein Labyrinth, mit dem Ziel, alle Punkte (Pellets) zu fressen, während er vier Geistern ausweicht. Das Gameplay zeichnet sich durch folgende Mechaniken aus:",[27,148,149,152,155],{},[30,150,151],{},"Tile-Based Navigation: Die gesamte Welt besteht aus einem Raster, das die Bewegung einschränkt und die Kollision mit Wänden definiert.",[30,153,154],{},"Power-Pellets: Das Einsammeln spezieller Items kehrt die Rollen kurzzeitig um, sodass Pac-Man die Geister fressen kann.",[30,156,157],{},"Warp-Tunnel: Seitliche Ausgänge, die den Spieler sofort auf die gegenüberliegende Seite des Spielfelds transportieren.",[11,159,46],{"id":45},[16,161,49],{},[27,163,164],{},[30,165,166,167,169,170,173,174,176,177,179],{},"Pac-Man: Tasten ",[56,168,58],{}," (Hoch), ",[56,171,172],{},"S"," (Runter), ",[56,175,62],{}," (Links), ",[56,178,66],{}," (Rechts)",[11,181,75],{"id":74},[27,183,184,187,190,193],{},[30,185,186],{},"Wegfindungs-KI: Die Wegfindung basiert auf \"Schildern\" die an den Kreuzungen stehen und\neine zufällige Auswahl an Wegen, nach Kreuzung, bietet.",[30,188,189],{},"State-Machine: Steuerung der verschiedenen Zustände von Pac-Man und den Geistern (Chase, Scatter, Frightened).",[30,191,192],{},"Tilemap-System: Effizientes Rendering des Labyrinths durch eine Tilemap, bei der die Map-Daten aus einem Array geladen werden.",[30,194,195],{},"Animations-System: Sprite-Sheet-Animationen für das Öffnen/Schließen des Mundes von Pac-Man.",{"title":103,"searchDepth":104,"depth":104,"links":197},[198,199,200,201],{"id":137,"depth":107,"text":138},{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},{"image":203,"video":204,"gif":103,"engine":103,"framework":116,"language":117,"devtime":205,"githubLink":206,"buildsystem":120,"downloads":207,"tags":210},"/games/pac-man/images/pac-man.png","/portfolioSite/games/pac-man/videos/pac-man.mp4","ca. 3 Monate","https://github.com/jjmercado/Pac-Man",{"windows":208,"linux":209},"/downloads/PacMan.zip","/downloads/PacMan.tar.gz",[117,116],"/games/pac-man",{"title":132,"description":141},"games/pac-man","BEpJYdRm-p7gze6VJMWzsLX-vEs5HYNKNAUJjMisxVc",{"id":216,"title":217,"body":218,"description":305,"extension":112,"meta":306,"navigation":125,"path":314,"seo":315,"stem":316,"__hash__":317},"games/games/pong.md","Pong",{"type":8,"value":219,"toc":299},[220,224,227,229,232,252,254,256,277,279],[11,221,223],{"id":222},"projektbeschreibung-pong","Projektbeschreibung: Pong",[16,225,226],{},"Dieses Projekt ist meine Umsetzung des Arcade-Klassikers Pong, ausgelegt als lokales 2-Spieler-Spiel. Entwickelt in C++ mit der SFML-Bibliothek, bietet es eine solide Basis, die gerne erweitert werden kann.",[11,228,22],{"id":21},[16,230,231],{},"Pong simuliert ein Tischtennis-Duell. Der Ball prallt von Wänden und Paddles ab.",[27,233,234,240,246],{},[30,235,236,239],{},[33,237,238],{},"Reflexions-Gameplay:"," Der Ball prallt von den oberen und unteren Begrenzungen sowie von den Spieler-Paddles ab.",[30,241,242,245],{},[33,243,244],{},"Punktesystem:"," Ein Punkt wird vergeben, wenn der Ball die hintere Spielfeldbegrenzung eines Spielers überschreitet. Das Spiel endet nach Erreichen einer vordefinierten Punktzahl.",[30,247,248,251],{},[33,249,250],{},"Game-Loop:"," Saubere Trennung von Input, Spiellogik und Rendering für flüssiges Gameplay.",[11,253,46],{"id":45},[16,255,49],{},[27,257,258,267],{},[30,259,260,261,263,264,266],{},"Linker Spieler: Tasten ",[56,262,58],{}," (hoch) und ",[56,265,172],{}," (runter)",[30,268,269,270,273,274],{},"Rechter Spieler: Pfeiltasten ",[56,271,272],{},"Oben"," und ",[56,275,276],{},"Unten",[11,278,75],{"id":74},[27,280,281,287,293],{},[30,282,283,286],{},[33,284,285],{},"Vektor-Reflexion:"," Mathematische Berechnung der Abprallwinkel. Die Flugbahn wird manipuliert, je nachdem, an welcher Stelle des Paddles der Ball auftrifft (Steilerer Winkel bei Treffern an den Kanten).",[30,288,289,292],{},[33,290,291],{},"AABB-Kollisionserkennung:"," Implementierung von Axis-Aligned Bounding Boxes zur schnellen und zuverlässigen Erkennung von Kollisionen zwischen Ball, Wänden und Paddles.",[30,294,295,298],{},[33,296,297],{},"UI & Scoring-System:"," Dynamische Anzeige des Spielstands mittels SFML-Text-Komponenten und Echtzeit-Aktualisierung des Spielfelds.",{"title":103,"searchDepth":104,"depth":104,"links":300},[301,302,303,304],{"id":222,"depth":107,"text":223},{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Umsetzung von Pong, dem Pionier der Videospielgeschichte. Entwickelt in C++ mit der SFML-Bibliothek, lag der Schwerpunkt hier auf der präzisen Berechnung von Reflexionsphysik, der Implementierung einer einfachen KI und der Synchronisation von Spielzuständen.",{"image":307,"video":308,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":309,"buildsystem":120,"downloads":310,"tags":313},"/games/pong/images/pong.png","/portfolioSite/games/pong/videos/pong.mp4","https://github.com/jjmercado/Pong",{"windows":311,"linux":312},"/downloads/Pong.zip","/downloads/Pong.tar.gz",[117,116],"/games/pong",{"title":217,"description":305},"games/pong","OvBwtZoRKAJ49iikGYVDPMen8z2gyCnbdklzvZHWEic",{"id":319,"title":320,"body":321,"description":387,"extension":112,"meta":388,"navigation":125,"path":396,"seo":397,"stem":398,"__hash__":399},"games/games/snake-classic.md","Snake Classic",{"type":8,"value":322,"toc":381},[323,327,330,332,335,346,348,365,367],[11,324,326],{"id":325},"projektbeschreibung-snake","Projektbeschreibung: Snake",[16,328,329],{},"Dieses Projekt ist meine Umsetzung des legendären Arcade-Klassikers Snake, entwickelt in C++ mit der SFML-Bibliothek. Das Ziel des Projekts war die Implementierung einer dynamischen Listen-Logik und eines grid-basierten Bewegungssystems, um die klassischen Gameplay-Mechaniken originalgetreu nachzubilden.",[11,331,22],{"id":21},[16,333,334],{},"Der Spieler steuert eine Schlange durch ein zweidimensionales Spielfeld. Mit jedem aufgenommenen Item wächst die Schlange, was die Navigation zunehmend erschwert. Die Kernmechaniken umfassen:",[27,336,337,340,343],{},[30,338,339],{},"Grid-Movement: Die Schlange bewegt sich in festen Schritten auf einem Gitter, wobei die Richtung nur um 90 Grad geändert werden kann.",[30,341,342],{},"Wachstums-Logik: Jedes Mal, wenn der Kopf der Schlange mit einem Futter-Objekt kollidiert, wird ein neues Segment am Ende angehängt.",[30,344,345],{},"Neustart: Das Spiel endet nicht es startet immer wieder neu, sobald der Kopf die Spielfeldbegrenzung berührt oder mit dem eigenen Körper kollidiert (Self-Collision).",[11,347,46],{"id":45},[27,349,350],{},[30,351,352,353,355,356,358,359,361,362,364],{},"Schlange: Taste ",[56,354,58],{}," (hoch), ",[56,357,172],{}," (runter), ",[56,360,62],{}," (links) und ",[56,363,66],{}," (rechts)",[11,366,75],{"id":74},[27,368,369,372,375,378],{},[30,370,371],{},"Datenstrukturen: Effiziente Verwaltung der Schlangensegmente, um das Nachrücken der Glieder performant zu berechnen.",[30,373,374],{},"Grid-basierte Kollisionserkennung: Prüfung der Positionen auf dem Koordinatensystem zur Erkennung von Treffern (Kopf vs. Futter oder Kopf vs. Körper).",[30,376,377],{},"Randomized Spawning: Algorithmus zur Platzierung von Futter auf freien Feldern, die nicht vom Körper der Schlange besetzt sind.",[30,379,380],{},"Frame-Rate Independent Logic: Trennung von Spielgeschwindigkeit (Tick-Rate) und Rendering, um die Schlangengeschwindigkeit unabhängig von der Bildwiederholrate zu steuern.",{"title":103,"searchDepth":104,"depth":104,"links":382},[383,384,385,386],{"id":325,"depth":107,"text":326},{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Snake, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken des Spiels von Grund auf zu programmieren.",{"image":389,"video":390,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":391,"buildsystem":120,"downloads":392,"tags":395},"/games/snake-classic/images/snake-classic.png","/portfolioSite/games/snake-classic/videos/snake-classic.mp4","https://github.com/jjmercado/Snake_classic",{"windows":393,"linux":394},"/downloads/SnakeApp.zip","/downloads/SnakeApp.tar.gz",[117,116],"/games/snake-classic",{"title":320,"description":387},"games/snake-classic","o17kbn-_fcHmRKb5gTC5MCBD7D4t3DxZATqBJqmU76I",[401,470,618],{"id":402,"title":403,"body":404,"date":461,"description":462,"extension":112,"meta":463,"navigation":125,"path":466,"seo":467,"stem":468,"__hash__":469},"polyslayer/devlog/polyslayer/erläuterung.md","Erläuterung",{"type":8,"value":405,"toc":458},[406,411,414,418,423,426,429,432,453,456],[407,408,410],"h1",{"id":409},"devlog-3-was-ist-alles-passiert","Devlog #3: Was ist alles passiert",[412,413],"hr",{},[11,415,417],{"id":416},"die-letzten-6-monate","Die letzten 6 Monate",[16,419,420],{},[33,421,422],{},"Vom Code-Enthusiasten zum Godot-User: Mein 2025 in der Spieleentwicklung",[16,424,425],{},"Eigentlich wollte ich Ende 2025 schon eine fertige Kampf-Demo präsentieren. Spoiler: Hat nicht ganz geklappt – aber aus den besten Gründen!",[16,427,428],{},"Nachdem mir Unity mit ihrem \"Cloud-Zwang\" und der unsicheren Preispolitik den letzten Nerv geraubt hat, bin ich komplett auf Godot umgestiegen. Ja, ich liebe C++ und hätte fast alles selbst programmiert, aber ich will ein Spiel fertigstellen und keine Engine-Entwicklungs-Odyssee starten.",[16,430,431],{},"Die letzten Monate waren ein riesiges Experimentierfeld:",[433,434,435,441,447],"ol",{},[30,436,437,440],{},[33,438,439],{},"Blender-Pipeline:"," Modelle, Häuser und Waffen exportieren, bis der Workflow sitzt.",[30,442,443,446],{},[33,444,445],{},"Leben in der Bude:"," Pathfinding für Wölfe und Hasen implementiert.",[30,448,449,452],{},[33,450,451],{},"Visuals:"," Shader-Spielereien und Partikeleffekte für leuchtende Schwerter.",[16,454,455],{},"Es hat länger gedauert als geplant, aber das Gelernte ist Gold wert. Jetzt bin ich bereit für das Kampfsystem!",[412,457],{},{"title":103,"searchDepth":104,"depth":104,"links":459},[460],{"id":416,"depth":107,"text":417},"2025-01-31T00:00:00.000Z","Was ist in den letzten 6 Monaten passiert",{"project":464,"project_image":465},"PolySlayer","/games/polyslayer/images/placeholder.png","/devlog/polyslayer/erlauterung",{"title":403,"description":462},"devlog/polyslayer/erläuterung","NOM6SZqr53uTrOd_EmAXFkF19ZdcRtGDo5OgARn3IEM",{"id":471,"title":472,"body":473,"date":611,"description":612,"extension":112,"meta":613,"navigation":125,"path":614,"seo":615,"stem":616,"__hash__":617},"polyslayer/devlog/polyslayer/statusQuo.md","Status-Quo",{"type":8,"value":474,"toc":607},[475,479,481,487,499,504,515,520,531,536,547,549,555,582,586,605],[407,476,478],{"id":477},"devlog-2-ein-vergleich","Devlog #2: Ein Vergleich",[412,480],{},[11,482,484],{"id":483},"teil-1-die-charakter-evolution",[33,485,486],{},"Teil 1: Die Charakter-Evolution",[27,488,489],{},[30,490,491,494],{},[33,492,493],{},"Bild 1: „Stunde Null: Der blaue Schwert-Prototyp“",[495,496],"nuxt-img",{"src":497,"alt":498},"/games/polyslayer/images/firstCharacter.png","firstCharacter",[27,500,501],{},[30,502,503],{},"Mein erster Entwurf! Hier ging es vor allem darum, den Workflow reinzukriegen und ein Gefühl für die Pipeline zu entwickeln.",[27,505,506],{},[30,507,508,511],{},[33,509,510],{},"Bild 2 „Level Up: Das neue Design mit Helm & Rüstung“",[495,512],{"src":513,"alt":514},"/games/polyslayer/images/secondCharacter.png","secondCharacter",[27,516,517],{},[30,518,519],{},"Back to the roots. Ich wollte unbedingt mehr in die Chibi-Richtung gehen – das war die Basis für den Look, den ich eigentlich im Kopf hatte.",[27,521,522],{},[30,523,524,527],{},[33,525,526],{},"Bild 3 „Level Up: Das aktuelle Design“",[495,528],{"src":529,"alt":530},"/games/polyslayer/images/thirdCharacter.png","thirdCharacter",[27,532,533],{},[30,534,535],{},"Der „Sweet Spot“. Eine schlankere Mischung aus V1 und V2. Das ist momentan mein absoluter Favorit und die finale Basis für die nächsten Schritte!",[27,537,538],{},[30,539,540,543],{},[33,541,542],{},"Video „In Action: Schwertschwung“",[544,545],"video",{"loop":125,"autoPlay":125,"src":546},"/portfolioSite/games/polyslayer/videos/version2Character.mp4",[412,548],{},[11,550,552],{"id":551},"teil-2-die-verwandlung-der-welt",[33,553,554],{},"Teil 2: Die Verwandlung der Welt",[27,556,557,565,573],{},[30,558,559,562],{},[33,560,561],{},"Video „Ein Blick zurück: Die alte Umgebung“",[544,563],{"loop":125,"autoPlay":125,"src":564},"/portfolioSite/games/polyslayer/videos/oldWorld.mp4",[30,566,567,570],{},[33,568,569],{},"Video „Erste Schritte: Orientierung in der Ur-Map“",[544,571],{"loop":125,"autoPlay":125,"src":572},"/portfolioSite/games/polyslayer/videos/oldWorldWalk.mp4",[30,574,575,578],{},[33,576,577],{},"Bild 3 „Vogelperspektive: Die erste Dorf-Planung“",[495,579],{"src":580,"alt":581},"/games/polyslayer/images/viewOfTown.png","viewoftown",[27,583,584],{},[30,585],{},[27,587,588,597],{},[30,589,590,593],{},[33,591,592],{},"Bild 4 „Details im Fokus: Brunnen, Windmühle & Fachwerk“",[495,594],{"src":595,"alt":596},"/games/polyslayer/images/viewOfTownNear.png","viewoftownnear",[30,598,599,602],{},[33,600,601],{},"Video „Parkour im Dorf: Das neue Spielgefühl“",[544,603],{"loop":125,"autoPlay":125,"src":604},"/portfolioSite/games/polyslayer/videos/newWorldWalk.mp4",[412,606],{},{"title":103,"searchDepth":104,"depth":104,"links":608},[609,610],{"id":483,"depth":107,"text":486},{"id":551,"depth":107,"text":554},"2025-01-30T00:00:00.000Z","Ein kleiner Eindruck was bereits geschaffen wurde",{"project":464,"project_image":465},"/devlog/polyslayer/statusquo",{"title":472,"description":612},"devlog/polyslayer/statusQuo","onQi0s8rsS1aVajYvIoXSpR7kqCRF0Jb7GXNloGRdwI",{"id":619,"title":620,"body":621,"date":794,"description":795,"extension":112,"meta":796,"navigation":125,"path":797,"seo":798,"stem":799,"__hash__":800},"polyslayer/devlog/polyslayer/die-vision.md","Die Vision",{"type":8,"value":622,"toc":788},[623,627,630,633,637,653,660,662,666,673,678,712,714,718,728,733,753,763,765,769,772,783,786],[407,624,626],{"id":625},"devlog-1-die-vision-epische-abenteuer-für-helden-mit-wenig-zeit","Devlog #1: Die Vision – Epische Abenteuer für Helden mit wenig Zeit",[16,628,629],{},"Hallo zusammen!",[16,631,632],{},"Nach gut sechs Monaten intensiver Arbeit hinter den Kulissen ist es endlich an der Zeit, den Vorhang zu lüften. Ich arbeite an einem Projekt, das tief in meiner eigenen Gaming-Biografie verwurzelt ist: Ein Singleplayer-Action-RPG, das die nostalgische Ästhetik der großen MMO-Ära mit dem rasanten Gameplay moderner Action-Titel verbindet.",[11,634,636],{"id":635},"die-vision-warum-dieses-spiel","Die Vision: Warum dieses Spiel?",[16,638,639,640,644,645,648,649,652],{},"Ich liebe die Welten von ",[641,642,643],"em",{},"World of Warcraft",", das übertriebene Design von ",[641,646,647],{},"Eudemons Online"," und das schnelle Kampfsystem von ",[641,650,651],{},"Cabal",". Aber wie viele von euch habe auch ich heute weniger Zeit als früher. Familie, Job und Alltag lassen oft keine 40-Stunden-Grinds pro Woche zu.",[16,654,655,656,659],{},"Mein Ziel ist es, ein Spiel zu erschaffen, das ",[33,657,658],{},"deine Zeit wertschätzt",". Ich möchte die Tiefe eines MMOs – mit Dungeons, Handwerk und epischem Fortschritt – in ein Singleplayer-Erlebnis packen, in das man auch für nur ein paar Stunden eintauchen kann, ohne das Gefühl zu haben, nichts erreicht zu haben.",[412,661],{},[11,663,665],{"id":664},"das-kern-konzept-freiheit-und-belohnung","Das Kern-Konzept: Freiheit und Belohnung",[16,667,668,669,672],{},"Der rote Faden des Spiels ist das Prinzip ",[33,670,671],{},"„High Risk, High Reward“",". Ich möchte keine künstlichen Schranken. Wenn du mutig genug bist, dich in ein gefährliches Gebiet zu wagen, sollst du belohnt werden. Du kannst dort seltene Materialien sammeln, auch wenn dein Level noch nicht ausreicht, um sie sofort zu verarbeiten. Diese Freiheit gibt dir die Macht über deinen eigenen Fortschritt.",[16,674,675],{},[33,676,677],{},"Die Key-Features im Überblick:",[27,679,680,690,700,706],{},[30,681,682,685,686,689],{},[33,683,684],{},"Waffen, die mit dir wachsen:"," Inspiriert von ",[641,687,688],{},"Eudemons",", wird Crafting visuell. Wenn du eine Waffe zur Meisterschaft veredelst, ändern sich nicht nur die Stats – sie wird von Flammen umhüllt oder erhält andere mächtige Effekte.",[30,691,692,695,696,699],{},[33,693,694],{},"Actionreiches Kampfsystem:"," Inspiriert von der Dynamik aus ",[641,697,698],{},"Cabal Online",". Schnelle Kämpfe, wuchtige Rüstungen und beeindruckende Effekte stehen im Fokus.",[30,701,702,705],{},[33,703,704],{},"Das Alpha-System:"," Jede Monsterart besitzt drei Stufen von Alpha-Tieren. Je höher die Stufe, desto gefährlicher das Biest – aber desto wertvoller auch die Beute.",[30,707,708,711],{},[33,709,710],{},"Dungeons & Gebiets-Quests:"," Statt endloser Textwüsten leiten dich Gebiets-Quests organisch durch die Welt, mit einem klaren Fokus auf knackige Dungeon-Runs.",[412,713],{},[11,715,717],{"id":716},"der-weg-der-ersten-6-monate-lernen-und-aufbauen","Der Weg der ersten 6 Monate: Lernen und Aufbauen",[16,719,720,721,273,724,727],{},"Da ich dieses Projekt in meiner Freizeit entwickle, war das letzte halbe Jahr eine Reise voller steiler Lernkurven. Ich habe mich intensiv in die ",[33,722,723],{},"Godot Engine",[33,725,726],{},"GDScript"," eingearbeitet und musste mir viele Workflows erst komplett neu erschließen.",[16,729,730],{},[33,731,732],{},"Was hinter den Kulissen passiert ist:",[27,734,735,741,747],{},[30,736,737,740],{},[33,738,739],{},"Pipeline-Entwicklung:"," Ich habe gelernt, wie ich 3D-Modelle erstelle, sie animiere und sauber in Godot implementiere – ein Bereich, mit dem ich vorher kaum Kontakt hatte.",[30,742,743,746],{},[33,744,745],{},"Engine-Systeme:"," Von der ersten Test-KI für Monster über das Pathfinding bis hin zu Experimenten mit Shadern und Partikel-Systemen (für die flammenden Schwerter!) habe ich das Fundament gelegt.",[30,748,749,752],{},[33,750,751],{},"Die Welt entsteht:"," Ein kleines, stimmungsvolles Dorf als erster Ankerpunkt ist bereits fertiggestellt.",[16,754,755,758,759,762],{},[33,756,757],{},"Aktueller Stand:","\nMomentan befinde ich mich in einer Phase der Verfeinerung. Ich überarbeite aktuell den ",[33,760,761],{},"Krieger-Hauptcharakter"," komplett. Die erste Version hat mir spielerisch noch nicht gefallen – und da das Spielgefühl („Game Feel“) das Herzstück eines Action-RPGs ist, nehme ich mir hier die Zeit, es richtig zu machen, bevor ich den Magier an gehe.",[412,764],{},[11,766,768],{"id":767},"wie-geht-es-weiter-roadmap","Wie geht es weiter? (Roadmap)",[16,770,771],{},"Der Plan für die nächsten Monate steht fest. Ich verfolge eine klare Kette von Schritten, um das Spielgefühl auf das nächste Level zu heben:",[433,773,774,777,780],{},[30,775,776],{},"Charakter-Feinschliff: Nachdem ich das Modell des Kriegers überarbeitet habe, erstelle ich aktuell die visuelle Repräsentation. Ich teste verschiedene Posen und Details in voller Farbe, um sicherzustellen, dass der Look genau die Wucht ausstrahlt, die ich mir vorstelle. Danach folgen die finalen Animationen.",[30,778,779],{},"Der erste Gegner: Mein Wolf-Modell steht bereits, benötigt aber noch bessere Animationen, damit die Kämpfe später glaubwürdig und dynamisch wirken.",[30,781,782],{},"Das Kampfsystem: Sobald die Animationen sitzen, widme ich mich dem Herzstück – dem Kampfsystem. Mein großes Ziel ist es, bis Mitte des Jahres eine erste, solide Implementierung des Combat-Systems fertig zu haben.",[16,784,785],{},"Im nächsten Devlog werde ich euch zeigen, was ich bisher visuell erreicht habe und wo ich bereits radikale Änderungen vorgenommen habe, weil mir die erste Version nicht gefallen hat. Ich glaube, dieser Prozess des „Scheiterns und Verbesserns“ gehört zum Game Dev einfach dazu.",[412,787],{},{"title":103,"searchDepth":104,"depth":104,"links":789},[790,791,792,793],{"id":635,"depth":107,"text":636},{"id":664,"depth":107,"text":665},{"id":716,"depth":107,"text":717},{"id":767,"depth":107,"text":768},"2025-01-29T00:00:00.000Z","Epische Abenteuer für Helden mit wenig Zeit",{"project":464,"project_image":529},"/devlog/polyslayer/die-vision",{"title":620,"description":795},"devlog/polyslayer/die-vision","sBNKLUCBVTa4YKYsCGnH6_L8LuRvIQS7HZdUAgUdgOM",1770302844459]