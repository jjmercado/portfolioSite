[{"data":1,"prerenderedAt":235},["ShallowReactive",2],{"games-list":3,"latest-posts-polyslayer":150},[4,86],{"id":5,"title":6,"body":7,"description":68,"extension":69,"meta":70,"navigation":81,"path":82,"seo":83,"stem":84,"__hash__":85},"games/games/asteroids.md","Asteroids",{"type":8,"value":9,"toc":60},"minimark",[10,15,19,23,26,39,43],[11,12,14],"h3",{"id":13},"projektbeschreibung-asteroids-c-sfml","Projektbeschreibung: Asteroids (C++ & SFML)",[16,17,18],"p",{},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek (Simple and Fast Multimedia Library). Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.",[11,20,22],{"id":21},"das-spielprinzip","Das Spielprinzip",[16,24,25],{},"Der Spieler steuert ein dreieckiges Raumschiff in einem zweidimensionalen Asteroidenfeld. Die Besonderheit liegt in der Steuerung und der Physik:",[27,28,29,33,36],"ul",{},[30,31,32],"li",{},"Trägheit: Das Schiff bewegt sich nach dem Beschleunigen physikalisch korrekt weiter, was     präzises Manövrieren erfordert.",[30,34,35],{},"Wrapping-World: Objekte, die den Bildschirmrand verlassen, erscheinen auf der gegenüberliegenden Seite wieder (Screen Wrapping).",[30,37,38],{},"Zerstörung: Große Asteroiden zerfallen bei Treffern in kleinere, schnellere Fragmente.",[11,40,42],{"id":41},"technische-highlights-features","Technische Highlights & Features",[27,44,45,48,51,54,57],{},[30,46,47],{},"Objektorientierte Programmierung: Umsetzung von Klassen für Ship, Bullet, Asteroid mit Vererbung und Polymorphie.",[30,49,50],{},"Vektorphysik: Berechnung Rotation und Geschwindigkeit basierend auf vektorieller Mathematik.",[30,52,53],{},"Kollisionserkennung: Implementierung von Hitboxen, um Interaktionen zwischen Geschossen, Asteroiden und dem Schiff zu prüfen.",[30,55,56],{},"Game Loop: Ein sauberer Game-Loop zur Trennung von Input-Verarbeitung, Logik-Update und Rendering.",[30,58,59],{},"Ressourcenmanagement: Laden und Verwalten von Texturen über SFML.",{"title":61,"searchDepth":62,"depth":62,"links":63},"",2,[64,66,67],{"id":13,"depth":65,"text":14},3,{"id":21,"depth":65,"text":22},{"id":41,"depth":65,"text":42},"Dieses Projekt ist eine moderne Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.","md",{"image":71,"video":72,"gif":61,"engine":61,"framework":73,"language":74,"devtime":75,"buildsystem":76,"downloads":77,"tags":80},"/games/asteroids/images/Asteroids.png","/games/asteroids/videos/Asteroids.mp4","SFML","C++","ca. 3 Monate","CMake",{"windows":78,"linux":79},"/downloads/crawler_win.zip","/downloads/Asteroids.tar.gz",[74,73],true,"/games/asteroids",{"title":6,"description":68},"games/asteroids","3SXwAKn-5cvqQk1fU2KYpMm3eGQj64JOn6-0377ivrI",{"id":87,"title":88,"body":89,"description":138,"extension":69,"meta":139,"navigation":81,"path":146,"seo":147,"stem":148,"__hash__":149},"games/games/snake-classic.md","Snake Classic",{"type":8,"value":90,"toc":133},[91,95,98,100,103,114,116],[11,92,94],{"id":93},"projektbeschreibung-snake-c-sfml","Projektbeschreibung: Snake (C++ & SFML)",[16,96,97],{},"Dieses Projekt ist meine Umsetzung des legendären Arcade-Klassikers Snake, entwickelt in C++ mit der SFML-Bibliothek. Das Ziel des Projekts war die Implementierung einer dynamischen Listen-Logik und eines grid-basierten Bewegungssystems, um die klassischen Gameplay-Mechaniken originalgetreu nachzubilden.",[11,99,22],{"id":21},[16,101,102],{},"Der Spieler steuert eine Schlange durch ein zweidimensionales Spielfeld. Mit jedem aufgenommenen Item wächst die Schlange, was die Navigation zunehmend erschwert. Die Kernmechaniken umfassen:",[27,104,105,108,111],{},[30,106,107],{},"Grid-Movement: Die Schlange bewegt sich in festen Schritten auf einem unsichtbaren Gitter, wobei die Richtung nur um 90 Grad geändert werden kann.",[30,109,110],{},"Wachstums-Logik: Jedes Mal, wenn der Kopf der Schlange mit einem Futter-Objekt kollidiert, wird ein neues Segment am Ende angehängt.",[30,112,113],{},"Game-Over-Conditions: Das Spiel endet, sobald der Kopf die Spielfeldbegrenzung berührt oder mit dem eigenen Körper kollidiert (Self-Collision).",[11,115,42],{"id":41},[27,117,118,121,124,127,130],{},[30,119,120],{},"Datenstrukturen: Effiziente Verwaltung der Schlangensegmente (z. B. mittels std::vector oder std::deque), um das Nachrücken der Glieder performant zu berechnen.",[30,122,123],{},"Input-Buffering: Implementierung eines Buffers für Tastatureingaben, um zu verhindern, dass die Schlange durch zu schnelle Richtungswechsel eine unmögliche 180-Grad-Wende in sich selbst vollführt.",[30,125,126],{},"Grid-basierte Kollisionserkennung: Mathematische Prüfung der Positionen auf dem Koordinatensystem zur Erkennung von Treffern (Kopf vs. Futter oder Kopf vs. Körper).",[30,128,129],{},"Randomized Spawning: Algorithmus zur Platzierung von Futter auf freien Feldern, die nicht vom Körper der Schlange besetzt sind.",[30,131,132],{},"Frame-Rate Independent Logic: Trennung von Spielgeschwindigkeit (Tick-Rate) und Rendering, um die Schlangengeschwindigkeit unabhängig von der Bildwiederholrate zu steuern.",{"title":61,"searchDepth":62,"depth":62,"links":134},[135,136,137],{"id":93,"depth":65,"text":94},{"id":21,"depth":65,"text":22},{"id":41,"depth":65,"text":42},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Snake, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken des Spiels von Grund auf zu programmieren.",{"image":140,"video":141,"gif":61,"engine":61,"framework":73,"language":74,"devtime":75,"buildsystem":76,"downloads":142,"tags":145},"/games/snake-classic/images/snake-classic.png","/games/snake-classic/videos/snake-classic.mp4",{"windows":143,"linux":144},"/downloads/SnakeApp.zip","/downloads/SnakeApp.tar.gz",[74,73],"/games/snake-classic",{"title":88,"description":138},"games/snake-classic","nHMIzx5Y5Z5tUtdHIenAu_rfyyaeU0YCrifiazPO1pU",[151,197],{"id":152,"title":153,"body":154,"date":189,"description":190,"extension":69,"meta":191,"navigation":81,"path":193,"seo":194,"stem":195,"__hash__":196},"polyslayer/devlog/polyslayer/zweiter-eintrag.md","Mein zweiter",{"type":8,"value":155,"toc":187},[156,161,164,167,183],[157,158,160],"h1",{"id":159},"willkommen-zu-meinem-devlog","Willkommen zu meinem Devlog",[16,162,163],{},"dungeon-crawler",[16,165,166],{},"anderer text",[168,169,173],"pre",{"className":170,"code":171,"language":172,"meta":61,"style":61},"language-javascript shiki shiki-themes github-light github-dark","console.log('Hello, Nuxt Content!');\n","javascript",[174,175,176],"code",{"__ignoreMap":61},[177,178,181],"span",{"class":179,"line":180},"line",1,[177,182,171],{},[184,185,186],"style",{},"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}",{"title":61,"searchDepth":62,"depth":62,"links":188},[],"2025-12-19T00:00:00.000Z","Eine kurze Zusammenfassung, worum es in diesem Eintrag geht.",{"project":163,"project_image":192},"/games/polyslayer/images/placeholder.png","/devlog/polyslayer/zweiter-eintrag",{"title":153,"description":190},"devlog/polyslayer/zweiter-eintrag","W38GfhBG0a5jUDuOP-QzSRg9Jafk5QBzL1pT9NpwRo8",{"id":198,"title":199,"body":200,"date":229,"description":190,"extension":69,"meta":230,"navigation":81,"path":231,"seo":232,"stem":233,"__hash__":234},"polyslayer/devlog/polyslayer/erster-eintrag.md","Mein erster Devlog-Eintrag! dung",{"type":8,"value":201,"toc":227},[202,204,206,209,217,225],[157,203,160],{"id":159},[16,205,163],{},[16,207,208],{},"Das ist der erste Eintrag, der mit Nuxt Content erstellt wurde. Es ist wirklich einfach!",[16,210,211,212,216],{},"Du kannst hier ganz normal ",[213,214,215],"strong",{},"Markdown"," verwenden.",[168,218,219],{"className":170,"code":171,"language":172,"meta":61,"style":61},[174,220,221],{"__ignoreMap":61},[177,222,223],{"class":179,"line":180},[177,224,171],{},[184,226,186],{},{"title":61,"searchDepth":62,"depth":62,"links":228},[],"2025-12-18T00:00:00.000Z",{"project":163,"project_image":192},"/devlog/polyslayer/erster-eintrag",{"title":199,"description":190},"devlog/polyslayer/erster-eintrag","tk8zsJ35nFIqd-uUVSoYHX1d2zEg0owwU278dE_V3-A",1768398534135]