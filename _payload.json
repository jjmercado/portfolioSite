[{"data":1,"prerenderedAt":365},["ShallowReactive",2],{"games-list":3,"latest-posts-polyslayer":280},[4,86,152,216],{"id":5,"title":6,"body":7,"description":68,"extension":69,"meta":70,"navigation":81,"path":82,"seo":83,"stem":84,"__hash__":85},"games/games/asteroids.md","Asteroids",{"type":8,"value":9,"toc":60},"minimark",[10,15,19,23,26,39,43],[11,12,14],"h3",{"id":13},"projektbeschreibung-asteroids","Projektbeschreibung: Asteroids",[16,17,18],"p",{},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek (Simple and Fast Multimedia Library). Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.",[11,20,22],{"id":21},"das-spielprinzip","Das Spielprinzip",[16,24,25],{},"Der Spieler steuert ein dreieckiges Raumschiff in einem zweidimensionalen Asteroidenfeld. Die Besonderheit liegt in der Steuerung und der Physik:",[27,28,29,33,36],"ul",{},[30,31,32],"li",{},"Trägheit: Das Schiff bewegt sich nach dem Beschleunigen physikalisch korrekt weiter, was     präzises Manövrieren erfordert.",[30,34,35],{},"Wrapping-World: Objekte, die den Bildschirmrand verlassen, erscheinen auf der gegenüberliegenden Seite wieder (Screen Wrapping).",[30,37,38],{},"Zerstörung: Große Asteroiden zerfallen bei Treffern in kleinere, schnellere Fragmente.",[11,40,42],{"id":41},"technische-highlights-features","Technische Highlights & Features",[27,44,45,48,51,54,57],{},[30,46,47],{},"Objektorientierte Programmierung: Umsetzung von Klassen für Ship, Bullet, Asteroid mit Vererbung und Polymorphie.",[30,49,50],{},"Vektorphysik: Berechnung Rotation und Geschwindigkeit basierend auf vektorieller Mathematik.",[30,52,53],{},"Kollisionserkennung: Implementierung von Hitboxen, um Interaktionen zwischen Geschossen, Asteroiden und dem Schiff zu prüfen.",[30,55,56],{},"Game Loop: Ein sauberer Game-Loop zur Trennung von Input-Verarbeitung, Logik-Update und Rendering.",[30,58,59],{},"Ressourcenmanagement: Laden und Verwalten von Texturen über SFML.",{"title":61,"searchDepth":62,"depth":62,"links":63},"",2,[64,66,67],{"id":13,"depth":65,"text":14},3,{"id":21,"depth":65,"text":22},{"id":41,"depth":65,"text":42},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.","md",{"image":71,"video":72,"gif":61,"engine":61,"framework":73,"language":74,"devtime":75,"buildsystem":76,"downloads":77,"tags":80},"/games/asteroids/images/Asteroids.png","/portfolioSite/games/asteroids/videos/Asteroids.mp4","SFML","C++","ca. 2 Monate","CMake",{"windows":78,"linux":79},"/downloads/crawler_win.zip","/downloads/Asteroids.tar.gz",[74,73],true,"/games/asteroids",{"title":6,"description":68},"games/asteroids","BbpHigEfuEV6ThXuaFTHBUIr3OjXvMFC27nR_ygRgA8",{"id":87,"title":88,"body":89,"description":97,"extension":69,"meta":141,"navigation":81,"path":148,"seo":149,"stem":150,"__hash__":151},"games/games/pac-man.md","Pac-Man",{"type":8,"value":90,"toc":136},[91,95,98,100,103,117,119],[11,92,94],{"id":93},"projektbeschreibung-pac-man","Projektbeschreibung: Pac-Man",[16,96,97],{},"Dieses Projekt ist meine Implementierung des zeitlosen Arcade-Hits Pac-Man, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Der Fokus lag hierbei auf der Umsetzung komplexer Pfadfindungs-Algorithmen und einer kachel-basierten (Tile-based) Weltlogik.",[11,99,22],{"id":21},[16,101,102],{},"Der Spieler steuert Pac-Man durch ein Labyrinth, mit dem Ziel, alle Punkte (Pellets) zu fressen, während er vier Geistern ausweicht. Das Gameplay zeichnet sich durch folgende Mechaniken aus:",[27,104,105,108,111,114],{},[30,106,107],{},"Tile-Based Navigation: Die gesamte Welt besteht aus einem Raster, das die Bewegung einschränkt und die Kollision mit Wänden definiert.",[30,109,110],{},"Geister-KI: Jedes der vier Geister-Objekte verfolgt eine eigene Strategie (z. B. direktes Verfolgen, Abfangen oder zufälliges Umherschweifen).",[30,112,113],{},"Power-Pellets: Das Einsammeln spezieller Items kehrt die Rollen kurzzeitig um, sodass Pac-Man die Geister fressen kann.",[30,115,116],{},"Warp-Tunnel: Seitliche Ausgänge, die den Spieler sofort auf die gegenüberliegende Seite des Spielfelds transportieren.",[11,118,42],{"id":41},[27,120,121,124,127,130,133],{},[30,122,123],{},"Wegfindungs-KI: Implementierung von Algorithmen zur Richtungsentscheidung der Geister (z. B. Ziel-Kachel-Berechnung basierend auf Distanzmetriken wie der Manhattan-Distanz).",[30,125,126],{},"State-Machine: Steuerung der verschiedenen Zustände von Pac-Man und den Geistern (Chase, Scatter, Frightened) mittels einer robusten State-Machine.",[30,128,129],{},"Tilemap-System: Effizientes Rendering des Labyrinths durch eine Tilemap, bei der die Map-Daten aus einer Textdatei oder einem Array geladen werden.",[30,131,132],{},"Präzise Kollisionslogik: Prüfung von Kollisionen auf Sub-Pixel-Ebene innerhalb des Rasters, um ein flüssiges „Abbiegen“ an Ecken zu ermöglichen (Pre-turn Logic).",[30,134,135],{},"Animations-System: Sprite-Sheet-Animationen für das Öffnen/Schließen des Mundes von Pac-Man sowie die Blickrichtung der Geister.",{"title":61,"searchDepth":62,"depth":62,"links":137},[138,139,140],{"id":93,"depth":65,"text":94},{"id":21,"depth":65,"text":22},{"id":41,"depth":65,"text":42},{"image":142,"video":143,"gif":61,"engine":61,"framework":73,"language":74,"devtime":144,"buildsystem":76,"downloads":145,"tags":147},"/games/pac-man/images/pac-man.png","/portfolioSite/games/pac-man/videos/pac-man.mp4","ca. 3 Monate",{"windows":78,"linux":146},"/downloads/PacMan.tar.gz",[74,73],"/games/pac-man",{"title":88,"description":97},"games/pac-man","tPPxxT3y_mCqj7YvvnwruKbaQQETLfo1O64mwRwBU-0",{"id":153,"title":154,"body":155,"description":203,"extension":69,"meta":204,"navigation":81,"path":212,"seo":213,"stem":214,"__hash__":215},"games/games/pong.md","Pong",{"type":8,"value":156,"toc":198},[157,161,164,166,168,179,181],[11,158,160],{"id":159},"projektbeschreibung-pong","Projektbeschreibung: Pong",[16,162,163],{},"Zwei Spieler (oder ein Spieler gegen den Computer) steuern vertikale Paddles am linken und rechten Bildschirmrand. Ziel ist es, einen Ball so zu schlagen, dass der Gegner ihn verfehlt.",[11,165,22],{"id":21},[16,167,102],{},[27,169,170,173,176],{},[30,171,172],{},"Reflexions-Gameplay: Der Ball prallt von den oberen und unteren Begrenzungen sowie von den Spieler-Paddles ab.",[30,174,175],{},"Dynamische Ballphysik: Die Geschwindigkeit des Balls erhöht sich nach jedem erfolgreichen Schlag, um den Schwierigkeitsgrad kontinuierlich zu steigern.",[30,177,178],{},"Punktesystem: Ein Punkt wird vergeben, wenn der Ball die hintere Spielfeldbegrenzung eines Spielers überschreitet. Das Spiel endet nach Erreichen einer vordefinierten Punktzahl.",[11,180,42],{"id":41},[27,182,183,186,189,192,195],{},[30,184,185],{},"Vektor-Reflexion: Mathematische Berechnung der Abprallwinkel. Die Flugbahn wird manipuliert, je nachdem, an welcher Stelle des Paddles der Ball auftrifft (Steilerer Winkel bei Treffern an den Kanten).",[30,187,188],{},"AABB-Kollisionserkennung: Implementierung von Axis-Aligned Bounding Boxes zur schnellen und zuverlässigen Erkennung von Kollisionen zwischen Ball, Wänden und Paddles.",[30,190,191],{},"Gegner-KI: Ein lernfähiger oder fest definierter Algorithmus für den Computergegner, der die Y-Position des Paddles basierend auf der Balltrajektorie verfolgt.",[30,193,194],{},"Screen-Shakes & Feedback: Implementierung von visuellen Effekten oder Sound-Triggern bei Kollisionen zur Verbesserung des \"Game Feels\".",[30,196,197],{},"UI & Scoring-System: Dynamische Anzeige des Spielstands mittels SFML-Text-Komponenten und Echtzeit-Aktualisierung des Spielfelds.",{"title":61,"searchDepth":62,"depth":62,"links":199},[200,201,202],{"id":159,"depth":65,"text":160},{"id":21,"depth":65,"text":22},{"id":41,"depth":65,"text":42},"Dieses Projekt ist meine Umsetzung von Pong, dem Pionier der Videospielgeschichte. Entwickelt in C++ mit der SFML-Bibliothek, lag der Schwerpunkt hier auf der präzisen Berechnung von Reflexionsphysik, der Implementierung einer einfachen KI und der Synchronisation von Spielzuständen.",{"image":205,"video":206,"gif":61,"engine":61,"framework":73,"language":74,"devtime":207,"githubLink":208,"buildsystem":76,"downloads":209,"tags":211},"/games/pong/images/pong.png","/portfolioSite/games/pong/videos/pong.mp4","ca. 1 Monate","https://github.com/jjmercado/Pong",{"windows":78,"linux":210},"/downloads/Pong.tar.gz",[74,73],"/games/pong",{"title":154,"description":203},"games/pong","PueBF55reX-njar_mEc1InwNteknyBDf3okGZDWsZEo",{"id":217,"title":218,"body":219,"description":268,"extension":69,"meta":269,"navigation":81,"path":276,"seo":277,"stem":278,"__hash__":279},"games/games/snake-classic.md","Snake Classic",{"type":8,"value":220,"toc":263},[221,225,228,230,233,244,246],[11,222,224],{"id":223},"projektbeschreibung-snake","Projektbeschreibung: Snake",[16,226,227],{},"Dieses Projekt ist meine Umsetzung des legendären Arcade-Klassikers Snake, entwickelt in C++ mit der SFML-Bibliothek. Das Ziel des Projekts war die Implementierung einer dynamischen Listen-Logik und eines grid-basierten Bewegungssystems, um die klassischen Gameplay-Mechaniken originalgetreu nachzubilden.",[11,229,22],{"id":21},[16,231,232],{},"Der Spieler steuert eine Schlange durch ein zweidimensionales Spielfeld. Mit jedem aufgenommenen Item wächst die Schlange, was die Navigation zunehmend erschwert. Die Kernmechaniken umfassen:",[27,234,235,238,241],{},[30,236,237],{},"Grid-Movement: Die Schlange bewegt sich in festen Schritten auf einem unsichtbaren Gitter, wobei die Richtung nur um 90 Grad geändert werden kann.",[30,239,240],{},"Wachstums-Logik: Jedes Mal, wenn der Kopf der Schlange mit einem Futter-Objekt kollidiert, wird ein neues Segment am Ende angehängt.",[30,242,243],{},"Game-Over-Conditions: Das Spiel endet, sobald der Kopf die Spielfeldbegrenzung berührt oder mit dem eigenen Körper kollidiert (Self-Collision).",[11,245,42],{"id":41},[27,247,248,251,254,257,260],{},[30,249,250],{},"Datenstrukturen: Effiziente Verwaltung der Schlangensegmente (z. B. mittels std::vector oder std::deque), um das Nachrücken der Glieder performant zu berechnen.",[30,252,253],{},"Input-Buffering: Implementierung eines Buffers für Tastatureingaben, um zu verhindern, dass die Schlange durch zu schnelle Richtungswechsel eine unmögliche 180-Grad-Wende in sich selbst vollführt.",[30,255,256],{},"Grid-basierte Kollisionserkennung: Mathematische Prüfung der Positionen auf dem Koordinatensystem zur Erkennung von Treffern (Kopf vs. Futter oder Kopf vs. Körper).",[30,258,259],{},"Randomized Spawning: Algorithmus zur Platzierung von Futter auf freien Feldern, die nicht vom Körper der Schlange besetzt sind.",[30,261,262],{},"Frame-Rate Independent Logic: Trennung von Spielgeschwindigkeit (Tick-Rate) und Rendering, um die Schlangengeschwindigkeit unabhängig von der Bildwiederholrate zu steuern.",{"title":61,"searchDepth":62,"depth":62,"links":264},[265,266,267],{"id":223,"depth":65,"text":224},{"id":21,"depth":65,"text":22},{"id":41,"depth":65,"text":42},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Snake, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken des Spiels von Grund auf zu programmieren.",{"image":270,"video":271,"gif":61,"engine":61,"framework":73,"language":74,"devtime":207,"buildsystem":76,"downloads":272,"tags":275},"/games/snake-classic/images/snake-classic.png","/portfolioSite/games/snake-classic/videos/snake-classic.mp4",{"windows":273,"linux":274},"/downloads/SnakeApp.zip","/downloads/SnakeApp.tar.gz",[74,73],"/games/snake-classic",{"title":218,"description":268},"games/snake-classic","OKdSsBTVQHTnRhVuDF6LjiS-1wEF2-UnqMHReijPjTw",[281,327],{"id":282,"title":283,"body":284,"date":319,"description":320,"extension":69,"meta":321,"navigation":81,"path":323,"seo":324,"stem":325,"__hash__":326},"polyslayer/devlog/polyslayer/zweiter-eintrag.md","Mein zweiter",{"type":8,"value":285,"toc":317},[286,291,294,297,313],[287,288,290],"h1",{"id":289},"willkommen-zu-meinem-devlog","Willkommen zu meinem Devlog",[16,292,293],{},"dungeon-crawler",[16,295,296],{},"anderer text",[298,299,303],"pre",{"className":300,"code":301,"language":302,"meta":61,"style":61},"language-javascript shiki shiki-themes github-light github-dark","console.log('Hello, Nuxt Content!');\n","javascript",[304,305,306],"code",{"__ignoreMap":61},[307,308,311],"span",{"class":309,"line":310},"line",1,[307,312,301],{},[314,315,316],"style",{},"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}",{"title":61,"searchDepth":62,"depth":62,"links":318},[],"2025-12-19T00:00:00.000Z","Eine kurze Zusammenfassung, worum es in diesem Eintrag geht.",{"project":293,"project_image":322},"/games/polyslayer/images/placeholder.png","/devlog/polyslayer/zweiter-eintrag",{"title":283,"description":320},"devlog/polyslayer/zweiter-eintrag","W38GfhBG0a5jUDuOP-QzSRg9Jafk5QBzL1pT9NpwRo8",{"id":328,"title":329,"body":330,"date":359,"description":320,"extension":69,"meta":360,"navigation":81,"path":361,"seo":362,"stem":363,"__hash__":364},"polyslayer/devlog/polyslayer/erster-eintrag.md","Mein erster Devlog-Eintrag! dung",{"type":8,"value":331,"toc":357},[332,334,336,339,347,355],[287,333,290],{"id":289},[16,335,293],{},[16,337,338],{},"Das ist der erste Eintrag, der mit Nuxt Content erstellt wurde. Es ist wirklich einfach!",[16,340,341,342,346],{},"Du kannst hier ganz normal ",[343,344,345],"strong",{},"Markdown"," verwenden.",[298,348,349],{"className":300,"code":301,"language":302,"meta":61,"style":61},[304,350,351],{"__ignoreMap":61},[307,352,353],{"class":309,"line":310},[307,354,301],{},[314,356,316],{},{"title":61,"searchDepth":62,"depth":62,"links":358},[],"2025-12-18T00:00:00.000Z",{"project":293,"project_image":322},"/devlog/polyslayer/erster-eintrag",{"title":329,"description":320},"devlog/polyslayer/erster-eintrag","tk8zsJ35nFIqd-uUVSoYHX1d2zEg0owwU278dE_V3-A",1768474735672]