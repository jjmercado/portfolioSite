[{"data":1,"prerenderedAt":83},["ShallowReactive",2],{"/games/snake-classic":3},{"id":4,"title":5,"body":6,"description":64,"extension":65,"meta":66,"navigation":78,"path":79,"seo":80,"stem":81,"__hash__":82},"games/games/snake-classic.md","Snake Classic",{"type":7,"value":8,"toc":56},"minimark",[9,14,18,22,25,38,42],[10,11,13],"h3",{"id":12},"projektbeschreibung-snake","Projektbeschreibung: Snake",[15,16,17],"p",{},"Dieses Projekt ist meine Umsetzung des legendären Arcade-Klassikers Snake, entwickelt in C++ mit der SFML-Bibliothek. Das Ziel des Projekts war die Implementierung einer dynamischen Listen-Logik und eines grid-basierten Bewegungssystems, um die klassischen Gameplay-Mechaniken originalgetreu nachzubilden.",[10,19,21],{"id":20},"das-spielprinzip","Das Spielprinzip",[15,23,24],{},"Der Spieler steuert eine Schlange durch ein zweidimensionales Spielfeld. Mit jedem aufgenommenen Item wächst die Schlange, was die Navigation zunehmend erschwert. Die Kernmechaniken umfassen:",[26,27,28,32,35],"ul",{},[29,30,31],"li",{},"Grid-Movement: Die Schlange bewegt sich in festen Schritten auf einem Gitter, wobei die Richtung nur um 90 Grad geändert werden kann.",[29,33,34],{},"Wachstums-Logik: Jedes Mal, wenn der Kopf der Schlange mit einem Futter-Objekt kollidiert, wird ein neues Segment am Ende angehängt.",[29,36,37],{},"Neustart: Das Spiel endet nicht es startet immer wieder neu, sobald der Kopf die Spielfeldbegrenzung berührt oder mit dem eigenen Körper kollidiert (Self-Collision).",[10,39,41],{"id":40},"technische-highlights-features","Technische Highlights & Features",[26,43,44,47,50,53],{},[29,45,46],{},"Datenstrukturen: Effiziente Verwaltung der Schlangensegmente, um das Nachrücken der Glieder performant zu berechnen.",[29,48,49],{},"Grid-basierte Kollisionserkennung: Prüfung der Positionen auf dem Koordinatensystem zur Erkennung von Treffern (Kopf vs. Futter oder Kopf vs. Körper).",[29,51,52],{},"Randomized Spawning: Algorithmus zur Platzierung von Futter auf freien Feldern, die nicht vom Körper der Schlange besetzt sind.",[29,54,55],{},"Frame-Rate Independent Logic: Trennung von Spielgeschwindigkeit (Tick-Rate) und Rendering, um die Schlangengeschwindigkeit unabhängig von der Bildwiederholrate zu steuern.",{"title":57,"searchDepth":58,"depth":58,"links":59},"",2,[60,62,63],{"id":12,"depth":61,"text":13},3,{"id":20,"depth":61,"text":21},{"id":40,"depth":61,"text":41},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Snake, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken des Spiels von Grund auf zu programmieren.","md",{"image":67,"video":68,"gif":57,"engine":57,"framework":69,"language":70,"devtime":71,"githubLink":72,"buildsystem":73,"downloads":74,"tags":77},"/games/snake-classic/images/snake-classic.png","/portfolioSite/games/snake-classic/videos/snake-classic.mp4","SFML","C++","ca. 1 Monate","https://github.com/jjmercado/Snake_classic","CMake",{"windows":75,"linux":76},"/downloads/SnakeApp.zip","/downloads/SnakeApp.tar.gz",[70,69],true,"/games/snake-classic",{"title":5,"description":64},"games/snake-classic","PSNukUD82so9xB3JG9kdqv9JjS_e5K5CddriGYArJQk",1768576871139]