[{"data":1,"prerenderedAt":86},["ShallowReactive",2],{"/games/snake-classic":3},{"id":4,"title":5,"body":6,"description":67,"extension":68,"meta":69,"navigation":81,"path":82,"seo":83,"stem":84,"__hash__":85},"games/games/snake-classic.md","Snake Classic",{"type":7,"value":8,"toc":59},"minimark",[9,14,18,22,25,38,42],[10,11,13],"h3",{"id":12},"projektbeschreibung-snake","Projektbeschreibung: Snake",[15,16,17],"p",{},"Dieses Projekt ist meine Umsetzung des legendären Arcade-Klassikers Snake, entwickelt in C++ mit der SFML-Bibliothek. Das Ziel des Projekts war die Implementierung einer dynamischen Listen-Logik und eines grid-basierten Bewegungssystems, um die klassischen Gameplay-Mechaniken originalgetreu nachzubilden.",[10,19,21],{"id":20},"das-spielprinzip","Das Spielprinzip",[15,23,24],{},"Der Spieler steuert eine Schlange durch ein zweidimensionales Spielfeld. Mit jedem aufgenommenen Item wächst die Schlange, was die Navigation zunehmend erschwert. Die Kernmechaniken umfassen:",[26,27,28,32,35],"ul",{},[29,30,31],"li",{},"Grid-Movement: Die Schlange bewegt sich in festen Schritten auf einem unsichtbaren Gitter, wobei die Richtung nur um 90 Grad geändert werden kann.",[29,33,34],{},"Wachstums-Logik: Jedes Mal, wenn der Kopf der Schlange mit einem Futter-Objekt kollidiert, wird ein neues Segment am Ende angehängt.",[29,36,37],{},"Game-Over-Conditions: Das Spiel endet, sobald der Kopf die Spielfeldbegrenzung berührt oder mit dem eigenen Körper kollidiert (Self-Collision).",[10,39,41],{"id":40},"technische-highlights-features","Technische Highlights & Features",[26,43,44,47,50,53,56],{},[29,45,46],{},"Datenstrukturen: Effiziente Verwaltung der Schlangensegmente (z. B. mittels std::vector oder std::deque), um das Nachrücken der Glieder performant zu berechnen.",[29,48,49],{},"Input-Buffering: Implementierung eines Buffers für Tastatureingaben, um zu verhindern, dass die Schlange durch zu schnelle Richtungswechsel eine unmögliche 180-Grad-Wende in sich selbst vollführt.",[29,51,52],{},"Grid-basierte Kollisionserkennung: Mathematische Prüfung der Positionen auf dem Koordinatensystem zur Erkennung von Treffern (Kopf vs. Futter oder Kopf vs. Körper).",[29,54,55],{},"Randomized Spawning: Algorithmus zur Platzierung von Futter auf freien Feldern, die nicht vom Körper der Schlange besetzt sind.",[29,57,58],{},"Frame-Rate Independent Logic: Trennung von Spielgeschwindigkeit (Tick-Rate) und Rendering, um die Schlangengeschwindigkeit unabhängig von der Bildwiederholrate zu steuern.",{"title":60,"searchDepth":61,"depth":61,"links":62},"",2,[63,65,66],{"id":12,"depth":64,"text":13},3,{"id":20,"depth":64,"text":21},{"id":40,"depth":64,"text":41},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Snake, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken des Spiels von Grund auf zu programmieren.","md",{"image":70,"video":71,"gif":60,"engine":60,"framework":72,"language":73,"devtime":74,"githubLink":75,"buildsystem":76,"downloads":77,"tags":80},"/games/snake-classic/images/snake-classic.png","/portfolioSite/games/snake-classic/videos/snake-classic.mp4","SFML","C++","ca. 1 Monate","https://github.com/jjmercado/Snake_classic","CMake",{"windows":78,"linux":79},"/downloads/SnakeApp.zip","/downloads/SnakeApp.tar.gz",[73,72],true,"/games/snake-classic",{"title":5,"description":67},"games/snake-classic","VnGykXsS-x_QLiwiybE1h7iqGoH-r2mY7PC-Sbo9Bk4",1768566343899]