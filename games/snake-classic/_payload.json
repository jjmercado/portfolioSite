[{"data":1,"prerenderedAt":110},["ShallowReactive",2],{"/games/snake-classic":3},{"id":4,"title":5,"body":6,"description":91,"extension":92,"meta":93,"navigation":105,"path":106,"seo":107,"stem":108,"__hash__":109},"games/games/snake-classic.md","Snake Classic",{"type":7,"value":8,"toc":82},"minimark",[9,14,18,22,25,38,42,64,68],[10,11,13],"h3",{"id":12},"projektbeschreibung-snake","Projektbeschreibung: Snake",[15,16,17],"p",{},"Dieses Projekt ist meine Umsetzung des legendären Arcade-Klassikers Snake, entwickelt in C++ mit der SFML-Bibliothek. Das Ziel des Projekts war die Implementierung einer dynamischen Listen-Logik und eines grid-basierten Bewegungssystems, um die klassischen Gameplay-Mechaniken originalgetreu nachzubilden.",[10,19,21],{"id":20},"das-spielprinzip","Das Spielprinzip",[15,23,24],{},"Der Spieler steuert eine Schlange durch ein zweidimensionales Spielfeld. Mit jedem aufgenommenen Item wächst die Schlange, was die Navigation zunehmend erschwert. Die Kernmechaniken umfassen:",[26,27,28,32,35],"ul",{},[29,30,31],"li",{},"Grid-Movement: Die Schlange bewegt sich in festen Schritten auf einem Gitter, wobei die Richtung nur um 90 Grad geändert werden kann.",[29,33,34],{},"Wachstums-Logik: Jedes Mal, wenn der Kopf der Schlange mit einem Futter-Objekt kollidiert, wird ein neues Segment am Ende angehängt.",[29,36,37],{},"Neustart: Das Spiel endet nicht es startet immer wieder neu, sobald der Kopf die Spielfeldbegrenzung berührt oder mit dem eigenen Körper kollidiert (Self-Collision).",[10,39,41],{"id":40},"steuerung","Steuerung",[26,43,44],{},[29,45,46,47,51,52,55,56,59,60,63],{},"Schlange: Taste ",[48,49,50],"kbd",{},"W"," (hoch), ",[48,53,54],{},"S"," (runter), ",[48,57,58],{},"A"," (links) und ",[48,61,62],{},"D"," (rechts)",[10,65,67],{"id":66},"technische-highlights-features","Technische Highlights & Features",[26,69,70,73,76,79],{},[29,71,72],{},"Datenstrukturen: Effiziente Verwaltung der Schlangensegmente, um das Nachrücken der Glieder performant zu berechnen.",[29,74,75],{},"Grid-basierte Kollisionserkennung: Prüfung der Positionen auf dem Koordinatensystem zur Erkennung von Treffern (Kopf vs. Futter oder Kopf vs. Körper).",[29,77,78],{},"Randomized Spawning: Algorithmus zur Platzierung von Futter auf freien Feldern, die nicht vom Körper der Schlange besetzt sind.",[29,80,81],{},"Frame-Rate Independent Logic: Trennung von Spielgeschwindigkeit (Tick-Rate) und Rendering, um die Schlangengeschwindigkeit unabhängig von der Bildwiederholrate zu steuern.",{"title":83,"searchDepth":84,"depth":84,"links":85},"",2,[86,88,89,90],{"id":12,"depth":87,"text":13},3,{"id":20,"depth":87,"text":21},{"id":40,"depth":87,"text":41},{"id":66,"depth":87,"text":67},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Snake, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken des Spiels von Grund auf zu programmieren.","md",{"image":94,"video":95,"gif":83,"engine":83,"framework":96,"language":97,"devtime":98,"githubLink":99,"buildsystem":100,"downloads":101,"tags":104},"/games/snake-classic/images/snake-classic.png","/portfolioSite/games/snake-classic/videos/snake-classic.mp4","SFML","C++","ca. 1 Monate","https://github.com/jjmercado/Snake_classic","CMake",{"windows":102,"linux":103},"/downloads/SnakeApp.zip","/downloads/SnakeApp.tar.gz",[97,96],true,"/games/snake-classic",{"title":5,"description":91},"games/snake-classic","o17kbn-_fcHmRKb5gTC5MCBD7D4t3DxZATqBJqmU76I",1770804220506]