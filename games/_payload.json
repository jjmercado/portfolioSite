[{"data":1,"prerenderedAt":340},["ShallowReactive",2],{"games-list":3},[4,100,167,275],{"id":5,"title":6,"body":7,"description":81,"extension":82,"meta":83,"navigation":95,"path":96,"seo":97,"stem":98,"__hash__":99},"games/games/asteroids.md","Asteroids",{"type":8,"value":9,"toc":73},"minimark",[10,15,19,23,26,43,47],[11,12,14],"h3",{"id":13},"projektbeschreibung-asteroids","Projektbeschreibung: Asteroids",[16,17,18],"p",{},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek (Simple and Fast Multimedia Library). Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.",[11,20,22],{"id":21},"das-spielprinzip","Das Spielprinzip",[16,24,25],{},"Der Spieler steuert ein dreieckiges Raumschiff in einem zweidimensionalen Asteroidenfeld. Die Besonderheit liegt in der Steuerung und der Physik:",[27,28,29,37],"ul",{},[30,31,32,36],"li",{},[33,34,35],"strong",{},"Wrapping-World:"," Objekte, die den Bildschirmrand verlassen, erscheinen auf der gegenüberliegenden Seite wieder (Screen Wrapping).",[30,38,39,42],{},[33,40,41],{},"Zerstörung:"," Große Asteroiden zerfallen bei Treffern in kleinere, schnellere Fragmente.",[11,44,46],{"id":45},"technische-highlights-features","Technische Highlights & Features",[27,48,49,55,61,67],{},[30,50,51,54],{},[33,52,53],{},"Vektorphysik:"," Berechnung Rotation und Geschwindigkeit basierend auf vektorieller Mathematik.",[30,56,57,60],{},[33,58,59],{},"Kollisionserkennung:"," Implementierung von Hitboxen, um Interaktionen zwischen Geschossen, Asteroiden und dem Schiff zu prüfen.",[30,62,63,66],{},[33,64,65],{},"Game Loop:"," Ein sauberer Game-Loop zur Trennung von Input-Verarbeitung, Logik-Update und Rendering.",[30,68,69,72],{},[33,70,71],{},"Ressourcenmanagement:"," Laden und Verwalten von Texturen über SFML.",{"title":74,"searchDepth":75,"depth":75,"links":76},"",2,[77,79,80],{"id":13,"depth":78,"text":14},3,{"id":21,"depth":78,"text":22},{"id":45,"depth":78,"text":46},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.","md",{"image":84,"video":85,"gif":74,"engine":74,"framework":86,"language":87,"devtime":88,"githubLink":89,"buildsystem":90,"downloads":91,"tags":94},"/games/asteroids/images/Asteroids.png","/portfolioSite/games/asteroids/videos/Asteroids.mp4","SFML","C++","ca. 1 Monate","https://github.com/jjmercado/Asteroids","CMake",{"windows":92,"linux":93},"/downloads/crawler_win.zip","/downloads/Asteroids.tar.gz",[87,86],true,"/games/asteroids",{"title":6,"description":81},"games/asteroids","2yRgpyM0mhBbuK_lonf_j8qj4pXIIgVsi1WfyM8_u8I",{"id":101,"title":102,"body":103,"description":111,"extension":82,"meta":155,"navigation":95,"path":163,"seo":164,"stem":165,"__hash__":166},"games/games/pac-man.md","Pac-Man",{"type":8,"value":104,"toc":150},[105,109,112,114,117,131,133],[11,106,108],{"id":107},"projektbeschreibung-pac-man","Projektbeschreibung: Pac-Man",[16,110,111],{},"Dieses Projekt ist meine Implementierung des zeitlosen Arcade-Hits Pac-Man, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Der Fokus lag hierbei auf der Umsetzung komplexer Pfadfindungs-Algorithmen und einer kachel-basierten (Tile-based) Weltlogik.",[11,113,22],{"id":21},[16,115,116],{},"Der Spieler steuert Pac-Man durch ein Labyrinth, mit dem Ziel, alle Punkte (Pellets) zu fressen, während er vier Geistern ausweicht. Das Gameplay zeichnet sich durch folgende Mechaniken aus:",[27,118,119,122,125,128],{},[30,120,121],{},"Tile-Based Navigation: Die gesamte Welt besteht aus einem Raster, das die Bewegung einschränkt und die Kollision mit Wänden definiert.",[30,123,124],{},"Geister-KI: Jedes der vier Geister-Objekte verfolgt eine eigene Strategie (z. B. direktes Verfolgen, Abfangen oder zufälliges Umherschweifen).",[30,126,127],{},"Power-Pellets: Das Einsammeln spezieller Items kehrt die Rollen kurzzeitig um, sodass Pac-Man die Geister fressen kann.",[30,129,130],{},"Warp-Tunnel: Seitliche Ausgänge, die den Spieler sofort auf die gegenüberliegende Seite des Spielfelds transportieren.",[11,132,46],{"id":45},[27,134,135,138,141,144,147],{},[30,136,137],{},"Wegfindungs-KI: Implementierung von Algorithmen zur Richtungsentscheidung der Geister (z. B. Ziel-Kachel-Berechnung basierend auf Distanzmetriken wie der Manhattan-Distanz).",[30,139,140],{},"State-Machine: Steuerung der verschiedenen Zustände von Pac-Man und den Geistern (Chase, Scatter, Frightened) mittels einer robusten State-Machine.",[30,142,143],{},"Tilemap-System: Effizientes Rendering des Labyrinths durch eine Tilemap, bei der die Map-Daten aus einer Textdatei oder einem Array geladen werden.",[30,145,146],{},"Präzise Kollisionslogik: Prüfung von Kollisionen auf Sub-Pixel-Ebene innerhalb des Rasters, um ein flüssiges „Abbiegen“ an Ecken zu ermöglichen (Pre-turn Logic).",[30,148,149],{},"Animations-System: Sprite-Sheet-Animationen für das Öffnen/Schließen des Mundes von Pac-Man sowie die Blickrichtung der Geister.",{"title":74,"searchDepth":75,"depth":75,"links":151},[152,153,154],{"id":107,"depth":78,"text":108},{"id":21,"depth":78,"text":22},{"id":45,"depth":78,"text":46},{"image":156,"video":157,"gif":74,"engine":74,"framework":86,"language":87,"devtime":158,"githubLink":159,"buildsystem":90,"downloads":160,"tags":162},"/games/pac-man/images/pac-man.png","/portfolioSite/games/pac-man/videos/pac-man.mp4","ca. 3 Monate","https://github.com/jjmercado/Pac-Man",{"windows":92,"linux":161},"/downloads/PacMan.tar.gz",[87,86],"/games/pac-man",{"title":102,"description":111},"games/pac-man","Py1UJvRlklXKx42VTMOEP2TF3Fsg_NwKozPmG84-bW4",{"id":168,"title":169,"body":170,"description":263,"extension":82,"meta":264,"navigation":95,"path":271,"seo":272,"stem":273,"__hash__":274},"games/games/pong.md","Pong",{"type":8,"value":171,"toc":257},[172,176,179,181,184,204,208,211,235,237],[11,173,175],{"id":174},"projektbeschreibung-pong","Projektbeschreibung: Pong",[16,177,178],{},"Dieses Projekt ist meine Umsetzung des Arcade-Klassikers Pong, ausgelegt als lokales 2-Spieler-Spiel. Entwickelt in C++ mit der SFML-Bibliothek, bietet es eine solide Basis, die gerne erweitert werden kann.",[11,180,22],{"id":21},[16,182,183],{},"Pong simuliert ein Tischtennis-Duell. Der Ball prallt von Wänden und Paddles ab.",[27,185,186,192,198],{},[30,187,188,191],{},[33,189,190],{},"Reflexions-Gameplay:"," Der Ball prallt von den oberen und unteren Begrenzungen sowie von den Spieler-Paddles ab.",[30,193,194,197],{},[33,195,196],{},"Punktesystem:"," Ein Punkt wird vergeben, wenn der Ball die hintere Spielfeldbegrenzung eines Spielers überschreitet. Das Spiel endet nach Erreichen einer vordefinierten Punktzahl.",[30,199,200,203],{},[33,201,202],{},"Game-Loop:"," Saubere Trennung von Input, Spiellogik und Rendering für flüssiges Gameplay.",[11,205,207],{"id":206},"steuerung","Steuerung",[16,209,210],{},"Das Spiel ist für zwei Spieler an einer Tastatur konzipiert:",[27,212,213,225],{},[30,214,215,216,220,221,224],{},"Linker Spieler: Tasten ",[217,218,219],"kbd",{},"W"," (hoch) und ",[217,222,223],{},"S"," (runter)",[30,226,227,228,231,232],{},"Rechter Spieler: Pfeiltasten ",[217,229,230],{},"Oben"," und ",[217,233,234],{},"Unten",[11,236,46],{"id":45},[27,238,239,245,251],{},[30,240,241,244],{},[33,242,243],{},"Vektor-Reflexion:"," Mathematische Berechnung der Abprallwinkel. Die Flugbahn wird manipuliert, je nachdem, an welcher Stelle des Paddles der Ball auftrifft (Steilerer Winkel bei Treffern an den Kanten).",[30,246,247,250],{},[33,248,249],{},"AABB-Kollisionserkennung:"," Implementierung von Axis-Aligned Bounding Boxes zur schnellen und zuverlässigen Erkennung von Kollisionen zwischen Ball, Wänden und Paddles.",[30,252,253,256],{},[33,254,255],{},"UI & Scoring-System:"," Dynamische Anzeige des Spielstands mittels SFML-Text-Komponenten und Echtzeit-Aktualisierung des Spielfelds.",{"title":74,"searchDepth":75,"depth":75,"links":258},[259,260,261,262],{"id":174,"depth":78,"text":175},{"id":21,"depth":78,"text":22},{"id":206,"depth":78,"text":207},{"id":45,"depth":78,"text":46},"Dieses Projekt ist meine Umsetzung von Pong, dem Pionier der Videospielgeschichte. Entwickelt in C++ mit der SFML-Bibliothek, lag der Schwerpunkt hier auf der präzisen Berechnung von Reflexionsphysik, der Implementierung einer einfachen KI und der Synchronisation von Spielzuständen.",{"image":265,"video":266,"gif":74,"engine":74,"framework":86,"language":87,"devtime":88,"githubLink":267,"buildsystem":90,"downloads":268,"tags":270},"/games/pong/images/pong.png","/portfolioSite/games/pong/videos/pong.mp4","https://github.com/jjmercado/Pong",{"windows":92,"linux":269},"/downloads/Pong.tar.gz",[87,86],"/games/pong",{"title":169,"description":263},"games/pong","Pn_2_pkROIl9ilzaMOjOBcMSP5tJOhTYeTkBMcQehxo",{"id":276,"title":277,"body":278,"description":327,"extension":82,"meta":328,"navigation":95,"path":336,"seo":337,"stem":338,"__hash__":339},"games/games/snake-classic.md","Snake Classic",{"type":8,"value":279,"toc":322},[280,284,287,289,292,303,305],[11,281,283],{"id":282},"projektbeschreibung-snake","Projektbeschreibung: Snake",[16,285,286],{},"Dieses Projekt ist meine Umsetzung des legendären Arcade-Klassikers Snake, entwickelt in C++ mit der SFML-Bibliothek. Das Ziel des Projekts war die Implementierung einer dynamischen Listen-Logik und eines grid-basierten Bewegungssystems, um die klassischen Gameplay-Mechaniken originalgetreu nachzubilden.",[11,288,22],{"id":21},[16,290,291],{},"Der Spieler steuert eine Schlange durch ein zweidimensionales Spielfeld. Mit jedem aufgenommenen Item wächst die Schlange, was die Navigation zunehmend erschwert. Die Kernmechaniken umfassen:",[27,293,294,297,300],{},[30,295,296],{},"Grid-Movement: Die Schlange bewegt sich in festen Schritten auf einem unsichtbaren Gitter, wobei die Richtung nur um 90 Grad geändert werden kann.",[30,298,299],{},"Wachstums-Logik: Jedes Mal, wenn der Kopf der Schlange mit einem Futter-Objekt kollidiert, wird ein neues Segment am Ende angehängt.",[30,301,302],{},"Game-Over-Conditions: Das Spiel endet, sobald der Kopf die Spielfeldbegrenzung berührt oder mit dem eigenen Körper kollidiert (Self-Collision).",[11,304,46],{"id":45},[27,306,307,310,313,316,319],{},[30,308,309],{},"Datenstrukturen: Effiziente Verwaltung der Schlangensegmente (z. B. mittels std::vector oder std::deque), um das Nachrücken der Glieder performant zu berechnen.",[30,311,312],{},"Input-Buffering: Implementierung eines Buffers für Tastatureingaben, um zu verhindern, dass die Schlange durch zu schnelle Richtungswechsel eine unmögliche 180-Grad-Wende in sich selbst vollführt.",[30,314,315],{},"Grid-basierte Kollisionserkennung: Mathematische Prüfung der Positionen auf dem Koordinatensystem zur Erkennung von Treffern (Kopf vs. Futter oder Kopf vs. Körper).",[30,317,318],{},"Randomized Spawning: Algorithmus zur Platzierung von Futter auf freien Feldern, die nicht vom Körper der Schlange besetzt sind.",[30,320,321],{},"Frame-Rate Independent Logic: Trennung von Spielgeschwindigkeit (Tick-Rate) und Rendering, um die Schlangengeschwindigkeit unabhängig von der Bildwiederholrate zu steuern.",{"title":74,"searchDepth":75,"depth":75,"links":323},[324,325,326],{"id":282,"depth":78,"text":283},{"id":21,"depth":78,"text":22},{"id":45,"depth":78,"text":46},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Snake, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken des Spiels von Grund auf zu programmieren.",{"image":329,"video":330,"gif":74,"engine":74,"framework":86,"language":87,"devtime":88,"githubLink":331,"buildsystem":90,"downloads":332,"tags":335},"/games/snake-classic/images/snake-classic.png","/portfolioSite/games/snake-classic/videos/snake-classic.mp4","https://github.com/jjmercado/Snake_classic",{"windows":333,"linux":334},"/downloads/SnakeApp.zip","/downloads/SnakeApp.tar.gz",[87,86],"/games/snake-classic",{"title":277,"description":327},"games/snake-classic","VnGykXsS-x_QLiwiybE1h7iqGoH-r2mY7PC-Sbo9Bk4",1768573027908]