[{"data":1,"prerenderedAt":382},["ShallowReactive",2],{"games-list":3},[4,130,197,300],{"id":5,"title":6,"body":7,"description":111,"extension":112,"meta":113,"navigation":125,"path":126,"seo":127,"stem":128,"__hash__":129},"games/games/asteroids.md","Asteroids",{"type":8,"value":9,"toc":102},"minimark",[10,15,19,23,26,43,47,50,72,76],[11,12,14],"h3",{"id":13},"projektbeschreibung-asteroids","Projektbeschreibung: Asteroids",[16,17,18],"p",{},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek (Simple and Fast Multimedia Library). Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.",[11,20,22],{"id":21},"das-spielprinzip","Das Spielprinzip",[16,24,25],{},"Der Spieler steuert ein dreieckiges Raumschiff in einem zweidimensionalen Asteroidenfeld. Die Besonderheit liegt in der Steuerung und der Physik:",[27,28,29,37],"ul",{},[30,31,32,36],"li",{},[33,34,35],"strong",{},"Wrapping-World:"," Objekte, die den Bildschirmrand verlassen, erscheinen auf der gegenüberliegenden Seite wieder (Screen Wrapping).",[30,38,39,42],{},[33,40,41],{},"Zerstörung:"," Große Asteroiden zerfallen bei Treffern in kleinere, schnellere Fragmente.",[11,44,46],{"id":45},"steuerung","Steuerung",[16,48,49],{},"Das Spiel ist für zwei Spieler an einer Tastatur konzipiert:",[27,51,52],{},[30,53,54,55,59,60,63,64,67,68,71],{},"Raumschiff: Taste ",[56,57,58],"kbd",{},"W"," (vorwärts), ",[56,61,62],{},"A"," (links Rotieren), ",[56,65,66],{},"D"," (rechts Rotieren) und ",[56,69,70],{},"Leertaste"," (schießen)",[11,73,75],{"id":74},"technische-highlights-features","Technische Highlights & Features",[27,77,78,84,90,96],{},[30,79,80,83],{},[33,81,82],{},"Vektorphysik:"," Berechnung Rotation und Geschwindigkeit basierend auf vektorieller Mathematik.",[30,85,86,89],{},[33,87,88],{},"Kollisionserkennung:"," Implementierung von Hitboxen, um Interaktionen zwischen Geschossen, Asteroiden und dem Schiff zu prüfen.",[30,91,92,95],{},[33,93,94],{},"Game Loop:"," Ein sauberer Game-Loop zur Trennung von Input-Verarbeitung, Logik-Update und Rendering.",[30,97,98,101],{},[33,99,100],{},"Ressourcenmanagement:"," Laden und Verwalten von Texturen über SFML.",{"title":103,"searchDepth":104,"depth":104,"links":105},"",2,[106,108,109,110],{"id":13,"depth":107,"text":14},3,{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Asteroids, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken eines 2D-Space-Shooters von Grund auf zu programmieren.","md",{"image":114,"video":115,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":119,"buildsystem":120,"downloads":121,"tags":124},"/games/asteroids/images/Asteroids.png","/portfolioSite/games/asteroids/videos/Asteroids.mp4","SFML","C++","ca. 1 Monate","https://github.com/jjmercado/Asteroids","CMake",{"windows":122,"linux":123},"/downloads/crawler_win.zip","/downloads/Asteroids.tar.gz",[117,116],true,"/games/asteroids",{"title":6,"description":111},"games/asteroids","Ko3ZYdwwwxLEfn9H3chsa_j6cKoaBoGQUUb2gIjfa7k",{"id":131,"title":132,"body":133,"description":141,"extension":112,"meta":185,"navigation":125,"path":193,"seo":194,"stem":195,"__hash__":196},"games/games/pac-man.md","Pac-Man",{"type":8,"value":134,"toc":180},[135,139,142,144,147,161,163],[11,136,138],{"id":137},"projektbeschreibung-pac-man","Projektbeschreibung: Pac-Man",[16,140,141],{},"Dieses Projekt ist meine Implementierung des zeitlosen Arcade-Hits Pac-Man, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Der Fokus lag hierbei auf der Umsetzung komplexer Pfadfindungs-Algorithmen und einer kachel-basierten (Tile-based) Weltlogik.",[11,143,22],{"id":21},[16,145,146],{},"Der Spieler steuert Pac-Man durch ein Labyrinth, mit dem Ziel, alle Punkte (Pellets) zu fressen, während er vier Geistern ausweicht. Das Gameplay zeichnet sich durch folgende Mechaniken aus:",[27,148,149,152,155,158],{},[30,150,151],{},"Tile-Based Navigation: Die gesamte Welt besteht aus einem Raster, das die Bewegung einschränkt und die Kollision mit Wänden definiert.",[30,153,154],{},"Geister-KI: Jedes der vier Geister-Objekte verfolgt eine eigene Strategie (z. B. direktes Verfolgen, Abfangen oder zufälliges Umherschweifen).",[30,156,157],{},"Power-Pellets: Das Einsammeln spezieller Items kehrt die Rollen kurzzeitig um, sodass Pac-Man die Geister fressen kann.",[30,159,160],{},"Warp-Tunnel: Seitliche Ausgänge, die den Spieler sofort auf die gegenüberliegende Seite des Spielfelds transportieren.",[11,162,75],{"id":74},[27,164,165,168,171,174,177],{},[30,166,167],{},"Wegfindungs-KI: Implementierung von Algorithmen zur Richtungsentscheidung der Geister (z. B. Ziel-Kachel-Berechnung basierend auf Distanzmetriken wie der Manhattan-Distanz).",[30,169,170],{},"State-Machine: Steuerung der verschiedenen Zustände von Pac-Man und den Geistern (Chase, Scatter, Frightened) mittels einer robusten State-Machine.",[30,172,173],{},"Tilemap-System: Effizientes Rendering des Labyrinths durch eine Tilemap, bei der die Map-Daten aus einer Textdatei oder einem Array geladen werden.",[30,175,176],{},"Präzise Kollisionslogik: Prüfung von Kollisionen auf Sub-Pixel-Ebene innerhalb des Rasters, um ein flüssiges „Abbiegen“ an Ecken zu ermöglichen (Pre-turn Logic).",[30,178,179],{},"Animations-System: Sprite-Sheet-Animationen für das Öffnen/Schließen des Mundes von Pac-Man sowie die Blickrichtung der Geister.",{"title":103,"searchDepth":104,"depth":104,"links":181},[182,183,184],{"id":137,"depth":107,"text":138},{"id":21,"depth":107,"text":22},{"id":74,"depth":107,"text":75},{"image":186,"video":187,"gif":103,"engine":103,"framework":116,"language":117,"devtime":188,"githubLink":189,"buildsystem":120,"downloads":190,"tags":192},"/games/pac-man/images/pac-man.png","/portfolioSite/games/pac-man/videos/pac-man.mp4","ca. 3 Monate","https://github.com/jjmercado/Pac-Man",{"windows":122,"linux":191},"/downloads/PacMan.tar.gz",[117,116],"/games/pac-man",{"title":132,"description":141},"games/pac-man","Py1UJvRlklXKx42VTMOEP2TF3Fsg_NwKozPmG84-bW4",{"id":198,"title":199,"body":200,"description":288,"extension":112,"meta":289,"navigation":125,"path":296,"seo":297,"stem":298,"__hash__":299},"games/games/pong.md","Pong",{"type":8,"value":201,"toc":282},[202,206,209,211,214,234,236,238,260,262],[11,203,205],{"id":204},"projektbeschreibung-pong","Projektbeschreibung: Pong",[16,207,208],{},"Dieses Projekt ist meine Umsetzung des Arcade-Klassikers Pong, ausgelegt als lokales 2-Spieler-Spiel. Entwickelt in C++ mit der SFML-Bibliothek, bietet es eine solide Basis, die gerne erweitert werden kann.",[11,210,22],{"id":21},[16,212,213],{},"Pong simuliert ein Tischtennis-Duell. Der Ball prallt von Wänden und Paddles ab.",[27,215,216,222,228],{},[30,217,218,221],{},[33,219,220],{},"Reflexions-Gameplay:"," Der Ball prallt von den oberen und unteren Begrenzungen sowie von den Spieler-Paddles ab.",[30,223,224,227],{},[33,225,226],{},"Punktesystem:"," Ein Punkt wird vergeben, wenn der Ball die hintere Spielfeldbegrenzung eines Spielers überschreitet. Das Spiel endet nach Erreichen einer vordefinierten Punktzahl.",[30,229,230,233],{},[33,231,232],{},"Game-Loop:"," Saubere Trennung von Input, Spiellogik und Rendering für flüssiges Gameplay.",[11,235,46],{"id":45},[16,237,49],{},[27,239,240,250],{},[30,241,242,243,245,246,249],{},"Linker Spieler: Tasten ",[56,244,58],{}," (hoch) und ",[56,247,248],{},"S"," (runter)",[30,251,252,253,256,257],{},"Rechter Spieler: Pfeiltasten ",[56,254,255],{},"Oben"," und ",[56,258,259],{},"Unten",[11,261,75],{"id":74},[27,263,264,270,276],{},[30,265,266,269],{},[33,267,268],{},"Vektor-Reflexion:"," Mathematische Berechnung der Abprallwinkel. Die Flugbahn wird manipuliert, je nachdem, an welcher Stelle des Paddles der Ball auftrifft (Steilerer Winkel bei Treffern an den Kanten).",[30,271,272,275],{},[33,273,274],{},"AABB-Kollisionserkennung:"," Implementierung von Axis-Aligned Bounding Boxes zur schnellen und zuverlässigen Erkennung von Kollisionen zwischen Ball, Wänden und Paddles.",[30,277,278,281],{},[33,279,280],{},"UI & Scoring-System:"," Dynamische Anzeige des Spielstands mittels SFML-Text-Komponenten und Echtzeit-Aktualisierung des Spielfelds.",{"title":103,"searchDepth":104,"depth":104,"links":283},[284,285,286,287],{"id":204,"depth":107,"text":205},{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Umsetzung von Pong, dem Pionier der Videospielgeschichte. Entwickelt in C++ mit der SFML-Bibliothek, lag der Schwerpunkt hier auf der präzisen Berechnung von Reflexionsphysik, der Implementierung einer einfachen KI und der Synchronisation von Spielzuständen.",{"image":290,"video":291,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":292,"buildsystem":120,"downloads":293,"tags":295},"/games/pong/images/pong.png","/portfolioSite/games/pong/videos/pong.mp4","https://github.com/jjmercado/Pong",{"windows":122,"linux":294},"/downloads/Pong.tar.gz",[117,116],"/games/pong",{"title":199,"description":288},"games/pong","Pn_2_pkROIl9ilzaMOjOBcMSP5tJOhTYeTkBMcQehxo",{"id":301,"title":302,"body":303,"description":369,"extension":112,"meta":370,"navigation":125,"path":378,"seo":379,"stem":380,"__hash__":381},"games/games/snake-classic.md","Snake Classic",{"type":8,"value":304,"toc":363},[305,309,312,314,317,328,330,347,349],[11,306,308],{"id":307},"projektbeschreibung-snake","Projektbeschreibung: Snake",[16,310,311],{},"Dieses Projekt ist meine Umsetzung des legendären Arcade-Klassikers Snake, entwickelt in C++ mit der SFML-Bibliothek. Das Ziel des Projekts war die Implementierung einer dynamischen Listen-Logik und eines grid-basierten Bewegungssystems, um die klassischen Gameplay-Mechaniken originalgetreu nachzubilden.",[11,313,22],{"id":21},[16,315,316],{},"Der Spieler steuert eine Schlange durch ein zweidimensionales Spielfeld. Mit jedem aufgenommenen Item wächst die Schlange, was die Navigation zunehmend erschwert. Die Kernmechaniken umfassen:",[27,318,319,322,325],{},[30,320,321],{},"Grid-Movement: Die Schlange bewegt sich in festen Schritten auf einem Gitter, wobei die Richtung nur um 90 Grad geändert werden kann.",[30,323,324],{},"Wachstums-Logik: Jedes Mal, wenn der Kopf der Schlange mit einem Futter-Objekt kollidiert, wird ein neues Segment am Ende angehängt.",[30,326,327],{},"Neustart: Das Spiel endet nicht es startet immer wieder neu, sobald der Kopf die Spielfeldbegrenzung berührt oder mit dem eigenen Körper kollidiert (Self-Collision).",[11,329,46],{"id":45},[27,331,332],{},[30,333,334,335,337,338,340,341,343,344,346],{},"Schlange: Taste ",[56,336,58],{}," (hoch), ",[56,339,248],{}," (runter), ",[56,342,62],{}," (links) und ",[56,345,66],{}," (rechts)",[11,348,75],{"id":74},[27,350,351,354,357,360],{},[30,352,353],{},"Datenstrukturen: Effiziente Verwaltung der Schlangensegmente, um das Nachrücken der Glieder performant zu berechnen.",[30,355,356],{},"Grid-basierte Kollisionserkennung: Prüfung der Positionen auf dem Koordinatensystem zur Erkennung von Treffern (Kopf vs. Futter oder Kopf vs. Körper).",[30,358,359],{},"Randomized Spawning: Algorithmus zur Platzierung von Futter auf freien Feldern, die nicht vom Körper der Schlange besetzt sind.",[30,361,362],{},"Frame-Rate Independent Logic: Trennung von Spielgeschwindigkeit (Tick-Rate) und Rendering, um die Schlangengeschwindigkeit unabhängig von der Bildwiederholrate zu steuern.",{"title":103,"searchDepth":104,"depth":104,"links":364},[365,366,367,368],{"id":307,"depth":107,"text":308},{"id":21,"depth":107,"text":22},{"id":45,"depth":107,"text":46},{"id":74,"depth":107,"text":75},"Dieses Projekt ist meine Implementierung des Arcade-Klassikers Snake, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Das Ziel war es, die grundlegenden Mechaniken des Spiels von Grund auf zu programmieren.",{"image":371,"video":372,"gif":103,"engine":103,"framework":116,"language":117,"devtime":118,"githubLink":373,"buildsystem":120,"downloads":374,"tags":377},"/games/snake-classic/images/snake-classic.png","/portfolioSite/games/snake-classic/videos/snake-classic.mp4","https://github.com/jjmercado/Snake_classic",{"windows":375,"linux":376},"/downloads/SnakeApp.zip","/downloads/SnakeApp.tar.gz",[117,116],"/games/snake-classic",{"title":302,"description":369},"games/snake-classic","o17kbn-_fcHmRKb5gTC5MCBD7D4t3DxZATqBJqmU76I",1768577337810]