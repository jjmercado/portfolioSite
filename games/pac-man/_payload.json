[{"data":1,"prerenderedAt":88},["ShallowReactive",2],{"/games/pac-man":3},{"id":4,"title":5,"body":6,"description":17,"extension":70,"meta":71,"navigation":83,"path":84,"seo":85,"stem":86,"__hash__":87},"games/games/pac-man.md","Pac-Man",{"type":7,"value":8,"toc":62},"minimark",[9,14,18,22,25,41,45],[10,11,13],"h3",{"id":12},"projektbeschreibung-pac-man","Projektbeschreibung: Pac-Man",[15,16,17],"p",{},"Dieses Projekt ist meine Implementierung des zeitlosen Arcade-Hits Pac-Man, entwickelt in C++ unter Verwendung der SFML-Bibliothek. Der Fokus lag hierbei auf der Umsetzung komplexer Pfadfindungs-Algorithmen und einer kachel-basierten (Tile-based) Weltlogik.",[10,19,21],{"id":20},"das-spielprinzip","Das Spielprinzip",[15,23,24],{},"Der Spieler steuert Pac-Man durch ein Labyrinth, mit dem Ziel, alle Punkte (Pellets) zu fressen, während er vier Geistern ausweicht. Das Gameplay zeichnet sich durch folgende Mechaniken aus:",[26,27,28,32,35,38],"ul",{},[29,30,31],"li",{},"Tile-Based Navigation: Die gesamte Welt besteht aus einem Raster, das die Bewegung einschränkt und die Kollision mit Wänden definiert.",[29,33,34],{},"Geister-KI: Jedes der vier Geister-Objekte verfolgt eine eigene Strategie (z. B. direktes Verfolgen, Abfangen oder zufälliges Umherschweifen).",[29,36,37],{},"Power-Pellets: Das Einsammeln spezieller Items kehrt die Rollen kurzzeitig um, sodass Pac-Man die Geister fressen kann.",[29,39,40],{},"Warp-Tunnel: Seitliche Ausgänge, die den Spieler sofort auf die gegenüberliegende Seite des Spielfelds transportieren.",[10,42,44],{"id":43},"technische-highlights-features","Technische Highlights & Features",[26,46,47,50,53,56,59],{},[29,48,49],{},"Wegfindungs-KI: Implementierung von Algorithmen zur Richtungsentscheidung der Geister (z. B. Ziel-Kachel-Berechnung basierend auf Distanzmetriken wie der Manhattan-Distanz).",[29,51,52],{},"State-Machine: Steuerung der verschiedenen Zustände von Pac-Man und den Geistern (Chase, Scatter, Frightened) mittels einer robusten State-Machine.",[29,54,55],{},"Tilemap-System: Effizientes Rendering des Labyrinths durch eine Tilemap, bei der die Map-Daten aus einer Textdatei oder einem Array geladen werden.",[29,57,58],{},"Präzise Kollisionslogik: Prüfung von Kollisionen auf Sub-Pixel-Ebene innerhalb des Rasters, um ein flüssiges „Abbiegen“ an Ecken zu ermöglichen (Pre-turn Logic).",[29,60,61],{},"Animations-System: Sprite-Sheet-Animationen für das Öffnen/Schließen des Mundes von Pac-Man sowie die Blickrichtung der Geister.",{"title":63,"searchDepth":64,"depth":64,"links":65},"",2,[66,68,69],{"id":12,"depth":67,"text":13},3,{"id":20,"depth":67,"text":21},{"id":43,"depth":67,"text":44},"md",{"image":72,"video":73,"gif":63,"engine":63,"framework":74,"language":75,"devtime":76,"githubLink":77,"buildsystem":78,"downloads":79,"tags":82},"/games/pac-man/images/pac-man.png","/portfolioSite/games/pac-man/videos/pac-man.mp4","SFML","C++","ca. 3 Monate","https://github.com/jjmercado/Pac-Man","CMake",{"windows":80,"linux":81},"/downloads/crawler_win.zip","/downloads/PacMan.tar.gz",[75,74],true,"/games/pac-man",{"title":5,"description":17},"games/pac-man","Py1UJvRlklXKx42VTMOEP2TF3Fsg_NwKozPmG84-bW4",1768577337808]